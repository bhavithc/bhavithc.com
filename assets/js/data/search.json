[ { "title": "Understand the asop repository", "url": "/posts/understand-the-asop-repository/", "categories": "aosp", "tags": "aosp", "date": "2024-06-11 21:50:02 +0530", "snippet": "When I first time cloned and build the aosp code, I was very much wonder how few commands can get us the android OSCommandsClone the repo$ repo init --partial-clone -b main -u https://android.googlesource.com/platform/manifest$ repo sync -c -j8Build the code$ source build/envsetup.sh$ lunch aosp_cf_x86_64_phone-trunk_staging-userdebug$ makeAndroid project is very big, the way the build systems are designed is pretty much amazing. just by executing the above commands with lot of patience, good computer and internet with in couple of hours say (~6Hrs) we get android os readySince I was new to repo tool, I was really fed up understanding the whole big picture. So here where I share my insights on how this aosp build worksEntire android repositories are maintained under some thing called Google Git which is similar to github.com where linux source is hosted.Google Git: https://android.googlesource.com/My first impression was that the UI of google git is very very bad to be frank. By looking at the UI itself we can’t able to understand what to clone and where to clone and which repo to clone. That job is taken care by repo tool, thanks to itI copied the content of Google Git to text file and executed cat google_git.txt | wc -l and found out that there are 2789 repositories present in Google git among them we need to start at some point, That is where repo tool clonesHere where our aosp first repo entry point exist The first entry point aosp build is https://android.googlesource.com/platform/manifest/ Click on more under tags in the above image now you will be under https://android.googlesource.com/platform/manifest/+refs Choose your favorite build number (tag) in my case I chose android-14.0.0_r22 -&amp;gt; click on it now end up in https://android.googlesource.com/platform/manifest/+/refs/heads/android-14.0.0_r22 This is where it contains a secrete file called default.xml which contain all further repo link to clone. Which you can think of like a submodules in git This file is copied to manifest folder under .repo folder then further clone will happen using this default.xmlWe know that is a very huge repo to clone and build, so we can add our own manifest, then we can add or remove the repo which is not required for usFor details refer raspberry pi aosp manifest filehttps://github.com/raspberry-vanilla/android_local_manifest/tree/android-14.0.0_r22 Note: Above notes are purely with my understanding, any thing which is not correct please pardon me and add a comments I gonna correct it" }, { "title": "Design Patterns Intents and Motivations", "url": "/posts/design-patterns-intents-and-motivations/", "categories": "design-pattern", "tags": "c++, cpp, design-pattern", "date": "2024-03-26 20:56:58 +0530", "snippet": "In this blog we gonna see about some of the important aspects of the design patterns such as Intent, Also known as, Motivation, Applicability, Structure, Participants and Related PatternsCreational Patterns Creational design patterns abstract the instantiation process They help make a system independent of how its objects are created, composed, and representedCreational patterns are of two kinds Class creational patterns: Uses inheritance to vary the class that’s instantiated Object creational patterns: Delegate instantiation to another objectThere are two recurring themes in these patterns They all encapsulate knowledge about which concrete classes the system uses They hide how instances of these classes are created and put togetherCreational patterns give you a lot of flexibility in what gets created who creates it how it gets created when it is createdThey let you configure a system with “product” objects that vary widely in structure and functionality Configuration can be static (that is, specified at compile-time) or dynamic (atrun-time)Factory MethodsIntentDefine an interface for creating an object, but let subclasses decide which class to instantiate. Factory Method lets a class defer instantiation to subclasses.Also Known AsVirtual ConstructorMotivation Consider a framework for an application that can create mutliple documents to the user The two key abstractions in this framework are Application class and Document class Example: To create a drawing application we need DrawingApplication and DrawingDocument The Application class is resposible for manging documents and will create them as on when required Application subclasses redefine an abstract CreateDocument operation on Application to return the appropriate Document subclass Once an Application subclass is instantiated, it can then instantiate application-specific Documents without knowing their classIn this case, We call CreateDocument a factory method because it’s responsible for “manufacturing” an objectApplicabilityUse the Factory Method pattern when A class can’t anticipate the class of objects it must create A class wants its subclasses to specify the objects it creates. classes delegate responsibility to one of several helper subclasses, and you want to localize the knowledge of which helper subclass is the delegateStructureParticipants Product (Document) defines the interface of objects the factory method creates. ConcreteProduct (MyDocument) implements the Product interface. Creator (Application) declares the factory method, which returns an object of type Product. Creator may also define a default implementation of the factory method that returns a default ConcreteProduct object. may call the factory method to create a Product object. ConcreteCreator (MyApplication) overrides the factory method to return an instance of a ConcreteProduct. Related Patterns Abstract Factory is often implemented with factory methods The Motivation example in the Abstract Factory pattern illustrates Factory Method as well Factory methods are usually called within Template MethodsAbstract FactoryIntentProvide an interface for creating families of related or dependent objects without specifying their concrete classes.Also Known AsKitMotivation Consider a user interface toolkit that supports multiple look-and-feel standards, such as Motif and Presentation Manager (PM) Different look-and-feels define different appearances and behaviors for user interface “widgets” like scroll bars, windows, and buttons To be portable across look-and-feel standards, an application should not hard-code its widgets for a particular look and feel Instantiating look-and-feel-specific classes of widgets throughout the application makes it hard to change the look and feel later We can solve this problem by defining an abstract WidgetFactory class that declares an interface for creating each basic kind of widget. Again here’s also an abstract class for each kind of widget, and concrete subclasses implement widgets for specific look-and-feel standards WidgetFactory’s interface has an operation that returns a new widget object for each abstract widget class Clients call these operations to obtain widget instances, but clients aren’t aware of the concreteclasses they’re using. Thus clients stay independent of the prevailing look and feel.ApplicabilityUse the Abstract Factory pattern when A system should be independent of how its products are created, composed, and represented. A system should be configured with one of multiple families of products. A family of related product objects is designed to be used together, and you need to enforce this constraint. you want to provide a class library of products, and you want to reveal just their interfaces, not their implementations.StructureParticipants AbstractFactory (WidgetFactory) declares an interface for operations that create abstract product objects ConcreteFactory (MotifWidgetFactory, PMWidgetFactory) implements the operations to create concrete product objects. AbstractProduct (Window, ScrollBar) declares an interface for a type of product object. ConcreteProduct (MotifWindow, MotifScrollBar) defines a product object to be created by the corresponding concrete factory. implements the AbstractProduct interface. Client uses only interfaces declared by AbstractFactory and AbstractProduct classes. Related Patterns AbstractFactory classes are often implemented with factory methods, but they can also be implemented using Prototype (lol) A concrete factory is often a singletonSingletonIntentEnsure a class only has one instance, and provide a global point of access to itMotivation It’s important for some classes to have exactly one instanceExamples Although there can be many printers in a system, there should be only one printer spooler There should be only one file system and one window manager A digital filter will have one A/D converter An accounting system will be dedicated to serving one company How do we ensure that a class has only one instance and that the instance is easily accessible? A global variable makes an object accessible, but it doesn’t keep you from instantiating multiple objects. A better solution is to make the class itself responsible for keeping track of its sole instance The class can ensure that no other instance can be created (by intercepting requests to create new objects), and it can provide a way to access the instance. This is the Singleton patternApplicabilityUse the Singleton pattern when There must be exactly one instance of a class, and it must be accessible to clients from a well-known access point when the sole instance should be extensible by subclassing, and clients should be able to use an extended instance without modifying their codeParticipants Singleton defines an Instance operation that lets clients access its unique instance. Instance is a class operation (that is, a class method in Smalltalk and a static member function in C++). may be responsible for creating its own unique instance. Related Patterns Many patterns can be implemented using the Singleton pattern, See Abstract Factory, Builder, and PrototypePrototypeIntentSpecify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.MotivationToday’s programming is all about costs. Saving is a big issue when it comes to using computer resources, so programmers are doing their best to find ways of improving the performance. When we talk about object creation we can find a better way to have new objects: cloning. To this idea one particular design pattern is related: rather than creation it uses cloning. If the cost of creating a new object is large and creation is resource intensive, we clone the object.ApplicabilityUse the Prototype pattern when a system should be independent of how its products are created, composed, and represented; and when the classes to instantiate are specified at run-time, for example, by dynamic loading; or to avoid building a class hierarchy of factories that parallels the class hierarchy of products; or when instances of a class can have one of only a few different combinations of state. It may be more convenient to install a corresponding number of prototypes and clone them rather than instantiating the class manually, each time with the appropriate state.StructureParticipants Prototype declares an interface for cloning itself. ConcretePrototype implements an operation for cloning itself. Client creates a new object by asking a prototype to clone itself. Collaborations A client asks a prototype to clone itself.Related Patterns Prototype and Abstract Factory are competing patterns in some ways. They can also be used together, however. An Abstract Factory might store a set of prototypes from which to clone and return product objects Designs that make heavy use of the Composite and Decorator patterns often can benefit from Prototype as wellBuilderIntentSeparate the construction of a complex object from its representation so that the same construction process can create different representations.MotivationA RTF Reader should able to convert to many text formats. The reader might convert RTF documents into plain ASCII text or into a text widget that can be edited interactively. The problem, however, is that the number of possible conversions is open-ended. So it should be easy to add a new conversion without modifying the readerA solution is to configure the RTFReader class with a TextConverter object that converts RTF to another textual representation. As the RTFReader parses the RTF document, it uses the TextConverter to perform the conversion.Whenever the RTFReader recognizes an RTF token, it issues a request to the TextConverter to convert the token.TextConverter objects are responsible both for performing the data conversion and for representing the token in a particular format.Subclasses of TextConverter specialize in different conversions and formats. For example, ASCIIConverter ignores requests to convert anything except plain text. TeXConverter, on the other hand, will implement operations for all requests in order to produce a TeX representation that captures all the stylistic information in the text TextWidgetConverter will produce a complex user interface object that lets the user see and edit the text.The Builder pattern captures all these relationships. Each converter class is called a builder in the pattern Reader is called the director.Builder pattern separates the algorithm for interpreting a textual format (that is, the parser for RTF documents) from how a converted format gets created and represented. This lets us reuse the RTFReader’s parsing algorithm to create different text representations from RTF documents—just configure the RTFReader with different subclasses of TextConverter.ApplicabilityUse the Builder pattern when Algorithm for creating a complex object should be independent of the parts that make up the object and how they’re assembled. Construction process must allow different representations for the object that’s constructedStructureParticipants Builder (TextConverter) specifies an abstract interface for creating parts of a Product object. ConcreteBuilder (ASCIIConverter, TeXConverter, TextWidgetConverter) constructs and assembles parts of the product by implementing the Builder interface. defines and keeps track of the representation it creates. provides an interface for retrieving the product (e.g., GetASCIIText, GetTextWidget). Director (RTFReader) constructs an object using the Builder interface. Product (ASCIIText, TeXText, TextWidget) represents the complex object under construction. ConcreteBuilder builds the product’s internal representation and defines the process by which it’s assembled. includes classes that define the constituent parts, including interfaces for assembling the parts into the final result. Related Patterns Abstract Factory is similar to Builder in that it too may construct complex objects. Difference between builder and abstract factory Builder Abstract factory Builder pattern focuses on constructing a complex object step by step Abstract Factory’s emphasis is on families of product objects (either simple or complex) Builder returns the product as a final step Abstract Factory pattern is concerned, the product gets returned immediately A Composite is what the builder often builds.Structral Patterns Structural patterns are concerned with how classes and objects are composed to form larger structures. Structural class patterns use inheritance to compose interfaces or implementations Structural object patterns describe ways to compose objects to realize new functionality The added flexibility of object composition comes from the ability to change the composition at run-time, which is impossible with static class composition.AdapterIntentConvert the interface of a class into another interface clients expect. Adapter lets classes work together that couldn’t otherwise because of incompatible interfacesAlso Known AsWrapperMotivationSometimes a toolkit class that’s designed for reuse isn’t reusable only because its interface doesn’t match the domain-specific interface an application requires.The adapter pattern is adapting between classes and objects. Like any adapter in the real world it is used to be an interface, a bridge between two objects.ApplicabilityUse the Adapter pattern when you want to use an existing class, and its interface does not match the one you need. you want to create a reusable class that cooperates with unrelated or unforeseen classes, that is, classes that don’t necessarily have compatible interfaces. (object adapter only) you need to use several existing subclasses, but it’s impractical to adapt their interface by subclassing every one. An object adapter can adapt the interface of its parent class.StructureType1: A class adapter uses multiple inheritance to adapt one interface to another:Type2: An object adapter relies on object composition:Participants Target defines the domain-specific interface that Client uses. Client collaborates with objects conforming to the Target interface. Adaptee defines an existing interface that needs adapting. Adapter adapts the interface of Adaptee to the Target interface. Note: Sometimes Adpater and Adaptee name makes lot of confusion, so better avoid it and use which better suits for the situationCollaborations Clients call operations on an Adapter instance. In turn, the adapter calls Adaptee operations that carry out the request.Known Uses Avoids tight coupling with third-party code Often used as a protection layer between application and third-party componentsRelated Patterns Bridge has a structure similar to an object adapter, but Bridge has a different intent: It is meant to separate an interface from its implementation so that they can be varied easily and independently. An adapter is meant to change the interface of an existing object. Decorator enhances another object without changing its interface. A decorator is thus more transparent to the application than an adapter is. As a consequence, Decorator supports recursive composition, which isn’t possible with pure adapters. Proxy defines a representative or surrogate for another object and does not change its interface.BridgeIntentDecouple an abstraction from its implementation so that the two can vary independently.Also Known AsHandle/BodyMotivation When an abstraction can have one of several possible implementations, the usual way to accommodate them is to use inheritance. An abstract class defines the interface to the abstraction, and concrete subclasses implement it in different ways. But this approach isn’t always flexible enough. Inheritance binds an implementation to the abstraction permanently, which makes it difficult to modify, extend, and reuse abstractions and implementations independently.Example: Consider the implementation of a portable Window abstraction in a user interface toolkit. This abstraction should enable us to write applications that work on both the X Window System and IBM’s Presentation Manager (PM), for example. Using inheritance, we could define an abstract class Window and subclasses XWindow andPMWindow that implement the Window interface for the different platforms. But this approach has two drawbacks: It’s inconvenient to extend the Window abstraction to cover different kinds of windows or new platforms. Imagine an IconWindow subclass of Window that specializes the Window abstraction for icons. To support IconWindows for both platforms, we have to implement two new classes, XIconWindow andPMIconWindow. Worse, we’ll have to define two classes for every kind of window. Supporting a third platform requires yet another new Window subclass for every kind of window. It makes client code platform-dependent. Whenever a client creates a window, it instantiates a concrete class that has a specific implementation. For example, creating an XWindow object binds the Window abstraction to the X Window implementation, which makes the client code dependent on the X Window implementation. This, in turn, makes it harder to port the client code to other platforms. Expectation: Clients should be able to create a window without committing to a concrete implementation. Only the window implementation should depend on the platform on which the application runs. Therefore client code should instantiate windows without mentioning specific platforms.Solution The Bridge pattern addresses these problems by putting the Window abstraction and its implementation in separate class hierarchies. There is one class hierarchy for window interfaces (Window, IconWindow, TransientWindow) and a separatehierarchy for platform-specific window implementations, with WindowImp as its root. The XWindowImp subclass, for example, provides an implementation based on the X Window System. All operations on Window subclasses are implemented in terms of abstract operations from the WindowImp interface. This decouples the window abstractions from the various platform-specific implementations We refer to the relationship between Window and WindowImp as a bridge, because it bridges the abstraction and its implementation, letting them vary independently.In simple instead of creating an interfaces and do inheritance, make it as seperate classes for interfaces and implementationsApplicabilityUse the Bridge pattern when you want to avoid a permanent binding between an abstraction and its implementation. This might be the case, for example, when the implementation must be selected or switched at run-time both the abstractions and their implementations should be extensible by subclassing. In this case, the Bridge pattern lets you combine the different abstractions and implementations and extend them independently. changes in the implementation of an abstraction should have no impact on clients; that is, their code should not have to be recompiled. - Client should not be recompiled (C++) you want to hide the implementation of an abstraction completely from clients. In C++ the representation of a class is visible in the class interface. -&amp;gt; here we can use pimpl idiom to avoid this as wellStructureParticipants Abstraction (Window) defines the abstraction’s interface. maintains a reference to an object of type Implementor. RefinedAbstraction (IconWindow) Extends the interface defined by Abstraction. Implementor (WindowImp) defines the interface for implementation classes. This interface doesn’t have to correspond exactly to Abstraction’s interface; in fact the two interfaces can be quite different. Typically the Implementor interface provides only primitive operations, and Abstraction defines higher-level operations based on these primitives. ConcreteImplementor (XWindowImp, PMWindowImp) implements the Implementor interface and defines its concrete implementation. Collaborations Abstraction forwards client requests to its Implementor object.Related Patterns An Abstract Factory can create and configure a particular Bridge. The Adapter pattern is geared toward making unrelated classes work together. It is usually applied to systems after they’re designed.Bridge, on the other hand, is used up-front in a design to let abstractions and implementations vary independently.CompositeIntentCompose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.MotivationGraphics applications like drawing editors and CAD systems let users build complex diagrams out of simple components. The user can group components to form larger components, which in turn can be grouped to form still larger components.Example: Group in PPT where user can group many small items and make a new componentA simple implementation could define classes for graphical primitives such as Text and Lines plus other classes that act as containers for these primitives. That is we can have a class which can hold Text, Lines and other grpups and acts as a containers. But there’s a problem with this approach: Code that uses these classes must treat primitive and container objects differently, even if most of the time the user treats them identically. Having to distinguish these objects makes the application more complex.The Composite pattern describes how to use recursive composition so that clients don’t have to make this distinction. The key to the Composite pattern is an abstract class that represents both primitives and their containers. For the graphics system, this class is Graphic. Graphic declares operations like Draw that are specific to graphical objects. It also declares operations that all composite objects share, such as operations for accessing and managing its children.The subclasses Line, Rectangle, and Text (see preceding class diagram) define primitive graphical objects. These classes implement Draw to draw lines, rectangles, and text, respectively. Since primitive graphics have no child graphics, none of these subclasses implements child-related operations.The Picture class defines an aggregate of Graphic objects. Picture implements Draw to call Draw on its children, and it implements child-related operations accordingly. Because the Picture interface conforms to the Graphic interface, Picture objects can compose other Pictures recursively.The following diagram shows a typical composite object structure of recursively composed Graphic objects:ApplicabilityUse the Composite pattern when you want to represent part-whole hierarchies of objects. you want clients to be able to ignore the difference between compositions of objects and individual objects. Clients will treat all objects in the composite structure uniformly.StructureParticipants Component (Graphic) declares the interface for objects in the composition. implements default behavior for the interface common to all classes, as appropriate. declares an interface for accessing and managing its child components. (optional) defines an interface for accessing a component’s parent in the recursive structure, and implements it if that’s appropriate. Leaf (Rectangle, Line, Text, etc.) represents leaf objects in the composition. A leaf has no children. defines behavior for primitive objects in the composition. Composite (Picture) defines behavior for components having children. stores child components. implements child-related operations in the Component interface. Client manipulates objects in the composition through the Component interface. Related Patterns Often the component-parent link is used for a Chain of Responsibility Decorator is often used with Composite. When decorators and composites are used together, they will usually have a common parent class. So decorators will have to support the Component interface with operations like Add, Remove, and GetChild. Flyweight lets you share components, but they can no longer refer to their parents. Iterator can be used to traverse composites. Visitor localizes operations and behavior that would otherwise be distributed across Composite and Leaf classes.DecoratorIntentAttach additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality." }, { "title": "Design Patterns Slides", "url": "/posts/design-patterns-in-c/", "categories": "design-pattern", "tags": "c++, cpp, design-pattern", "date": "2024-03-19 20:38:52 +0530", "snippet": "Design Patterns in C++Here are some of the helpful slide which is derived from Gang of four" }, { "title": "Is const reference always thread safe when used as function parameter?", "url": "/posts/is-const-reference-always-thread-safe-when-used-as-function-parameter/", "categories": "c", "tags": "c++, threading", "date": "2023-02-21 23:30:00 +0530", "snippet": "Many people has a fear of thread safety when using const reference as parameter to a function. As usual lets start with some examples and understand the thread safety of const referenceLets consider simple Test objectstruct Test{ Test() { } void name(std::string t) { m_name = t; } std::string name() const { return m_name; } std::string m_name{};};Let’s create a function foo which has void foo(const Test&amp;amp; testObj, const int threadNr); as signature with thread safety using lock_guard and create two thread in mainstd::mutex g_mtx;void foo(const Test&amp;amp; testObj, const int threadNr){ std::lock_guard&amp;lt;std::mutex&amp;gt; lock(g_mtx); if (threadNr == 1) { std::this_thread::sleep_for(std::chrono::seconds(1)); } std::cout &amp;lt;&amp;lt; &quot;Thread &quot; &amp;lt;&amp;lt; threadNr &amp;lt;&amp;lt; &quot; name is &quot; &amp;lt;&amp;lt; testObj.name() &amp;lt;&amp;lt; &quot;\\n&quot;;}int main(){ Test t; t.name(&quot;test1&quot;); // Start thread 1 std::thread t1 {foo, t, 1}; // update the name t.name(&quot;test2&quot;); std::this_thread::sleep_for(std::chrono::milliseconds(1000)); // Start thread 2 std::thread t2 {foo, t, 2}; if (t1.joinable()) { t1.join(); } if (t2.joinable()) { t2.join(); } return 0;}Output:bhavith@bhavith:~/testing$ ./a.outThread 1 name is test1Thread 2 name is test2Output looks fine right?Lets make some modification, instead of reference let’s update to pointervoid foo(const Test* testObj, const int threadNr){ std::lock_guard&amp;lt;std::mutex&amp;gt; lock(g_mtx); if (threadNr == 1) { std::this_thread::sleep_for(std::chrono::seconds(1)); } std::cout &amp;lt;&amp;lt; &quot;Thread &quot; &amp;lt;&amp;lt; threadNr &amp;lt;&amp;lt; &quot; name is &quot; &amp;lt;&amp;lt; testObj-&amp;gt;name() &amp;lt;&amp;lt; &quot;\\n&quot;;}// Update t to &amp;amp;t since we need to pass addressstd::thread t1 {foo, &amp;amp;t, 1}; std::thread t2 {foo, &amp;amp;t, 2};Output:bhavith@bhavith:~/testing$ ./a.outThread 1 name is test2Thread 2 name is test2Expected:Thread 1 name is test1Actual:Thread 1 name is test2Why is behavior so? I know you people have already guessed it. Yes, pointer in both the thread points to the same Test object.But the question is, why reference did not have same behavior as pointer?In order to understand why reference does not have same behavior as pointer, let’s add copy constructor to Test class and get back foo to use reference signaturevoid foo(const Test&amp;amp; testObj, const int threadNr)std::thread t1 {foo, t, 1};std::thread t2 {foo, t, 2}; Test(const Test&amp;amp; t) { std::cout &amp;lt;&amp;lt; &quot;Copy ctor \\n&quot;; m_name = t.m_name; }Now let’s re-execute the code.Output:bhavith@bhavith:~/testing$ ./a.outCopy CtorCopy CtorThread 1 name is test1Thread 2 name is test2Can you observe here, every time, when function is called, a brand new Test object is created by invoking copy constructor, but this is not the case with pointer.Let’s prove it by adding some cout’svoid foo(const Test&amp;amp; testObj, const int threadNr){ std::lock_guard&amp;lt;std::mutex&amp;gt; lock(g_mtx); std::cout &amp;lt;&amp;lt; &quot;Object address in thread &quot; &amp;lt;&amp;lt; threadNr &amp;lt;&amp;lt; &quot; is &quot; &amp;lt;&amp;lt; &amp;amp;testObj &amp;lt;&amp;lt; &quot;\\n&quot;; if (threadNr == 1) { std::this_thread::sleep_for(std::chrono::seconds(1)); } std::cout &amp;lt;&amp;lt; &quot;Thread &quot; &amp;lt;&amp;lt; threadNr &amp;lt;&amp;lt; &quot; name is &quot; &amp;lt;&amp;lt; testObj.name() &amp;lt;&amp;lt; &quot;\\n&quot;;}int main(){ Test t; std::cout &amp;lt;&amp;lt; &quot;Original object address is &quot; &amp;lt;&amp;lt; &amp;amp;t &amp;lt;&amp;lt; &quot;\\n&quot;; t.name(&quot;test1&quot;); std::thread t1 {foo, t, 1}; // update the name t.name(&quot;test2&quot;); std::this_thread::sleep_for(std::chrono::milliseconds(1000)); std::thread t2 {foo, t, 2}; if (t1.joinable()) { t1.join(); } if (t2.joinable()) { t2.join(); } return 0;}Output:bhavith@bhavith:~/testing$ ./a.outOriginal object address is 0x7ffc05d84690Copy CtorObject address in thread 1 is 0x5610595982d0Copy CtorThread 1 name is test1Object address in thread 2 is 0x561059598440Thread 2 name is test2Here you can see that Test object is local to the function foo. From this it is understood that, we can use const reference without any fear of thread safety.What about using shared_ptr as a parameter to function foo. Please let me know in comment section." }, { "title": "Do you know int main takes three arguments", "url": "/posts/do-you-know-int-main-takes-three-arguments/", "categories": "c", "tags": "c++, c, linux", "date": "2022-06-29 22:00:00 +0530", "snippet": "Many of us know how to read command line arguments from the program in C/C++#include &amp;lt;iostream&amp;gt;int main(int argc, char** pArgv){ for (int i = 0; i &amp;lt; argc; i++) { std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot; - &quot; &amp;lt;&amp;lt; pArgv[i] &amp;lt;&amp;lt; &quot;\\n&quot;; } return 0;}Output:bhavith@bhavith:$ ./a.out first second 0 - ./a.out1 - first2 - secondBut do you know int main takes one more argument, i.e. pointer to an list of environment variable#include &amp;lt;iostream&amp;gt;int main(int argc, char** pArgv, char** pEnv) { char** pTmp = pEnv; while (*pTmp != nullptr) { std::cout &amp;lt;&amp;lt; *pTmp &amp;lt;&amp;lt; &quot;\\n&quot;; pTmp++; } std::cout &amp;lt;&amp;lt; &quot;End of the list \\n&quot;; return 0;}I ran the program in https://www.programiz.com/cpp-programming/online-compiler/ and this is the output :)Output:KUBERNETES_PORT=tcp://10.0.0.1:443KUBERNETES_SERVICE_PORT=443PROGRAMIZ_COMPILER_WEB_UI_SEVICE_PORT_80_TCP_ADDR=10.0.14.233HOSTNAME=programiz-compiler-deployment-755649f487-8zgzdPROGRAMIZ_COMPILER_WEB_UI_SEVICE_PORT_80_TCP_PORT=80HOME=/home/compilerPROGRAMIZ_COMPILER_WEB_UI_SEVICE_PORT_80_TCP_PROTO=tcpPROGRAMIZ_COMPILER_SERVICE_HOST=10.0.10.151PS1=PROGRAMIZ_COMPILER_WEB_UI_SEVICE_PORT_80_TCP=tcp://10.0.14.233:80PROGRAMIZ_COMPILER_SERVICE_PORT=80PROGRAMIZ_COMPILER_PORT=tcp://10.0.10.151:80TERM=xtermKUBERNETES_PORT_443_TCP_ADDR=10.0.0.1PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/binPROGRAMIZ_COMPILER_PORT_80_TCP_ADDR=10.0.10.151KUBERNETES_PORT_443_TCP_PORT=443KUBERNETES_PORT_443_TCP_PROTO=tcpPROGRAMIZ_COMPILER_PORT_80_TCP_PORT=80PROGRAMIZ_COMPILER_PORT_80_TCP_PROTO=tcpPROGRAMIZ_COMPILER_WEB_UI_SEVICE_SERVICE_HOST=10.0.14.233GCC_COLORS=KUBERNETES_PORT_443_TCP=tcp://10.0.0.1:443KUBERNETES_SERVICE_PORT_HTTPS=443KUBERNETES_SERVICE_HOST=10.0.0.1PWD=/appPROGRAMIZ_COMPILER_PORT_80_TCP=tcp://10.0.10.151:80PROGRAMIZ_COMPILER_WEB_UI_SEVICE_SERVICE_PORT=80PROGRAMIZ_COMPILER_WEB_UI_SEVICE_PORT=tcp://10.0.14.233:80End of the list " }, { "title": "Adapter design pattern", "url": "/posts/adapter-design-pattern/", "categories": "design-pattern", "tags": "c++, cpp, design-pattern", "date": "2022-06-25 06:59:00 +0530", "snippet": "Definition: Adapter is a structural design pattern that allows objects with incompatible interfaces to collaborate.You may have browsed already many other places and might have watched lot of videos in order to understand it, lot of places there are N number of examples and you may fed up understanding it or might be confused especially if you are new to design patterns. Since design patterns are programming language agnostic. Each of the online tutorial uses different programming languages. Most of the times you end up seeing examples on Java or C#.In this post I am going to explain about Adapter design pattern using some story and I use C++ programming language.You are working in a UI development team for a fitness application. End product is a small hand held display especially made for software developer (lol), where he can click on developer option and can see all activities in XML formatWe have two character in this story Srinivas (Manager) Bhavith (Developer)Srinivas (Manager): Hey Bhavith, could you please develop a developer mode for our activity screen, where user can toggle developer option and can see all the activity in XML format?Bhavith (Developer): Yes Srini, I do some analysis and get back to you tomorrow.Bhavith: On next day, Hey Srini, Since we have less time and cannot develop XML parser ourself due to time constraint, So I am planning to use 3rd party library for XML parser is that fine with you?Srinivas: Yes, please go ahead since we are near to release and don’t reinvent the wheel, go ahead and use 3rd partyBhavith: Again after few hours, Srini, I collected all available XML parser library and found that JacksonXmlParser supports for C++ which is very suits best for our use case. But there is one catch we need to pay a little amount for thatSrinivas: How much?Bhavith: It’s not too high, $5 one time.Srinivas: Hey, please use our corporate credit card and pass over the bill via email. Rest I gonna take care.Bhavith: Next morning will full josh, Let’s start coding.const std::string&amp;amp; dummyXml = &quot;&amp;lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot;?&amp;gt;\\n&quot;\\ &quot;&amp;lt;Agenda type=\\&quot;gardening\\&quot;&amp;gt;\\n&quot;\\ &quot; &amp;lt;Activity type=\\&quot;Watering\\&quot;&amp;gt;\\n&quot;\\ &quot; &amp;lt;golf-course time=\\&quot;6:00\\&quot;/&amp;gt;\\n&quot;\\ &quot; &amp;lt;yard time=\\&quot;7:00\\&quot;/&amp;gt;\\n&quot;\\ &quot; &amp;lt;/Activity&amp;gt;\\n&quot;\\ &quot; &amp;lt;Activity type=\\&quot;cooking\\&quot;&amp;gt;\\n&quot;\\ &quot; &amp;lt;lunch time=\\&quot;12:00\\&quot;/&amp;gt;\\n&quot;\\ &quot; &amp;lt;/Activity&amp;gt;\\n&quot;\\ &quot;&amp;lt;/Agenda&amp;gt;\\n&quot;;/// Jackson parser library pseducodeclass JacksonXmlParser{public: JacksonXmlParser(const std::string xmlFile) : m_xmlFile(xmlFile) { } std::string jacksonParseXml() { return dummyXml; }private: std::string m_xmlFile = &quot;&quot;;};class Renderer{public: void renderXmlData() { JacksonXmlParser jx(&quot;data.xml&quot;); const auto data = jx.jacksonParseXml(); std::cout &amp;lt;&amp;lt; data &amp;lt;&amp;lt; &quot;\\n&quot;; }};int main(){ Renderer renderer; renderer.renderXmlData(); return 0;}Output:bhavith@bhavith:$ ./a.out &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;Agenda type=&quot;gardening&quot;&amp;gt; &amp;lt;Activity type=&quot;Watering&quot;&amp;gt; &amp;lt;golf-course time=&quot;6:00&quot;/&amp;gt; &amp;lt;yard time=&quot;7:00&quot;/&amp;gt; &amp;lt;/Activity&amp;gt; &amp;lt;Activity type=&quot;cooking&quot;&amp;gt; &amp;lt;lunch time=&quot;12:00&quot;/&amp;gt; &amp;lt;/Activity&amp;gt;&amp;lt;/Agenda&amp;gt;Bhavith: Srini, can you please look at this output?Srinivas: Woow, beautiful this is what I expected. great man keep it upNow developers are happy and customer is happy. Every thing was going smooth. One fine day, there was a email from jacksonXmlParserFrom: jackson@jacksonxmlparser.comHey Bhavith, Hope you are doing great and enjoying our JacksonXmlParser library. we have some news for you. Since our company is no more Jackson and we are now a part of Michael group. From next year onwards, our pricing plans have changed, Now on there won&#39;t be any one time subscription, rather annual subscription and the annual subscription price is $150. Since you are our loyal customer we have a offer and you can pay just $100.RegardsTeam Michael (Former Jackson)Bhavith: Damn, how could they do these things to us, they would have told at the time when we purchasedBhavith went to SrinivasBhavith: Hey Srini, We need to move to annual subscription plan for our Jackson library. Can I use corporatecredit card to make paymentSrinivas: No, please wait. Since we don’t have enough budget to afford such a big amount and that to every year. Also what if they change the plan next year and ask us to pay $250. Please think of something else.Bhavith: Browsed entire day and found one more library at the end of the google search called OpenXmlParser and surprisingly it was an open source libraryBhavith: Hey Srini, I have a good news for you, there was a open source project running from last year on Xml parser and it is completely free, why can’t we incorporate that in our projectSrinivas: Sounds, cool please go ahead once we deliver the product to customer, we can contribute to OpenXmlparser as well. Good job!Bhavith is now happy and looked into a API’s. He found there was a change in signature and he wan’t to reimplement the solution. Hey came to office on weekends and tagged current version to jackson-xml and reimplemented the solutionclass OpenXmlParser{public: std::string openParser(const std::string&amp;amp; xmlFile) { return dummyXml; }};class Renderer{public: void renderXmlData() { OpenXmlParser openXmlParser; const auto data = openXmlParser.openParser(&quot;data.xml&quot;); std::cout &amp;lt;&amp;lt; data &amp;lt;&amp;lt; &quot;\\n&quot;; }};int main(){ Renderer renderer; renderer.renderXmlData(); return 0;}Output:bhavith@bhavith:$ ./a.out &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;Agenda type=&quot;gardening&quot;&amp;gt; &amp;lt;Activity type=&quot;Watering&quot;&amp;gt; &amp;lt;golf-course time=&quot;6:00&quot;/&amp;gt; &amp;lt;yard time=&quot;7:00&quot;/&amp;gt; &amp;lt;/Activity&amp;gt; &amp;lt;Activity type=&quot;cooking&quot;&amp;gt; &amp;lt;lunch time=&quot;12:00&quot;/&amp;gt; &amp;lt;/Activity&amp;gt;&amp;lt;/Agenda&amp;gt;Bhavith: Srini, look at this, we got the same output as we expected.Srinivas: Good job, Bhavith, please take 20% hike this time ! After few day, end user started getting bugs, XML was jumbled up one on another. Finally testing team figured out there is a bug on XML rendering. Now developer reproduced it and found that there is a defect in xml parser and also there is open issue going on OpenXmlParserNow again Srinivas came to Bhavith and asked him, Bhavith please revert back the xml parser to JacksonXmlParser and I will pay it as of now, we cannot lose customer.Now Bhavith has to rewrite the whole software again, and that to everything he has to revert back. During the development again Srinivas came back to Bhavith and asked him to support both, We give paid customer with JacksonXmlParser and OpenXmlparser to free users.Now Bhavith is completely in soup and changes his status to open to work in Linkedin. But his friend came to him and asked, what is the problem.The problem is both library has different interfacesclass OpenXmlParser{public: std::string openParser(const std::string&amp;amp; xmlFile);};andclass JacksonXmlParser{public: JacksonXmlParser(const std::string xmlFile); std::string jacksonParseXml();private: std::string m_xmlFile = &quot;&quot;;};Bhavith: See bro here, both the classes have different signature to parse, how can I solve this one. I cannot create two executable for two different customersLoyal friend: Bro, just create your interface to prase and create a signature how ever you want, and pass to me. I gonna solve itNow Bhavith created a interface for XML parser, how he wants.class IXmlParser{public: virtual std::string parseXml(const std::string&amp;amp; xmlFile) = 0;};Bhavith: Bro, look at here, I created one you asked, Please help me.Loyal friend took some time and refactor the codeclass JacksonXmlAdapter : public IXmlParser{public: std::string parseXml(const std::string&amp;amp; xmlFile) override { JacksonXmlParser xmlParser(xmlFile); return xmlParser.jacksonParseXml(); }};class OpenXmlParserAdapter : public IXmlParser{public: std::string parseXml(const std::string&amp;amp; xmlFile) override { OpenXmlParser xmlParser; return xmlParser.openParser(xmlFile); }};class Renderer{public: enum class Type { Jackson, OpenXml, }; void renderXmlData(Type type) { std::shared_ptr&amp;lt;IXmlParser&amp;gt; pXmlparser = nullptr; std::string data(&quot;Invalid data&quot;); if (type == Type::Jackson) { std::cout &amp;lt;&amp;lt; &quot;Debug: Parsing xml using jackson parser ...\\n\\n&quot;; pXmlparser = std::make_shared&amp;lt;JacksonXmlAdapter&amp;gt;(); } else { std::cout &amp;lt;&amp;lt; &quot;Debug: Parsing xml using open xml parser ...\\n\\n&quot;; pXmlparser = std::make_shared&amp;lt;OpenXmlParserAdapter&amp;gt;(); } if (pXmlparser) { data = pXmlparser-&amp;gt;parseXml(&quot;data.xml&quot;); } std::cout &amp;lt;&amp;lt; data &amp;lt;&amp;lt; &quot;\\n&quot;; }};int main(int argc, char** pArgv){ Renderer::Type renderType = Renderer::Type::OpenXml; if (argc == 1) { std::cout &amp;lt;&amp;lt; &quot;Invalid usage: \\n&quot;; std::cout &amp;lt;&amp;lt; &quot;Usage: &quot; &amp;lt;&amp;lt; pArgv[0] &amp;lt;&amp;lt; &quot; - &amp;lt;type&amp;gt;\\nWhere type:\\n0 - To parse using Jackson parser \\n&quot;; std::cout &amp;lt;&amp;lt; &quot;1 - To parse using open xml parser \\n&quot;; return EXIT_FAILURE; } const int type = std::atoi(pArgv[1]); if (type == 0) { renderType = Renderer::Type::Jackson; } Renderer renderer; renderer.renderXmlData(renderType); return 0;}Output:bhavith@bhavith:$ ./a.out Invalid usage: Usage: ./a.out - &amp;lt;type&amp;gt;Where type:0 - To parse using Jackson parser 1 - To parse using open xml parserbhavith@bhavith:$ ./a.out 0Debug: Parsing xml using jackson parser ...&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;Agenda type=&quot;gardening&quot;&amp;gt; &amp;lt;Activity type=&quot;Watering&quot;&amp;gt; &amp;lt;golf-course time=&quot;6:00&quot;/&amp;gt; &amp;lt;yard time=&quot;7:00&quot;/&amp;gt; &amp;lt;/Activity&amp;gt; &amp;lt;Activity type=&quot;cooking&quot;&amp;gt; &amp;lt;lunch time=&quot;12:00&quot;/&amp;gt; &amp;lt;/Activity&amp;gt;&amp;lt;/Agenda&amp;gt;bhavith@bhavith:$ ./a.out 1Debug: Parsing xml using open xml parser ...&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;&amp;lt;Agenda type=&quot;gardening&quot;&amp;gt; &amp;lt;Activity type=&quot;Watering&quot;&amp;gt; &amp;lt;golf-course time=&quot;6:00&quot;/&amp;gt; &amp;lt;yard time=&quot;7:00&quot;/&amp;gt; &amp;lt;/Activity&amp;gt; &amp;lt;Activity type=&quot;cooking&quot;&amp;gt; &amp;lt;lunch time=&quot;12:00&quot;/&amp;gt; &amp;lt;/Activity&amp;gt;&amp;lt;/Agenda&amp;gt;Carefully look at the code, How Bhavith’s friend refactor the code and make it work for both uses cases, Just we have to pass a command line argument to use which ever the XML parser we want.This is what adapter design is for.Here we have two adapter’s JacksonXmlAdapter OpenXmlParserAdapterAlso we have two adoptee’s JacksonXmlParser OpenXmlParser His friend just create a wrapper, that wrapper we call as Adapter and he wrapped some thing, that some thing is called Adoptee.Now on Bhavith can use N number of xml parsers and his application scales up drastically. That is the beauty of Adapter design patternWhen can I choose Adapter design pattern? It is very simple, Thumb rule is, When ever there you want to work with 3rd party library in your software, close your eyes and go ahead and implement Adapter design pattern 3rd party always no need to be an external library, it could be a piece of code, where you feel interface may keep change in futureIf you really like the post please do the following You can connect me on LinkedIn LinkedIn Subscribe to my youtube channel YoutubeBhavith CPassionate Programmer and Teacher" }, { "title": "Track heap allocation as well check memory leaks in C++ programmatically", "url": "/posts/track-heap-allocation-in-c/", "categories": "c++", "tags": "c++, cpp, operator-overloading", "date": "2022-06-18 17:49:00 +0530", "snippet": "How can we track number of bytes allocated in heap for the given object.We know that allocating a memory in heap is costly, if we want to know exactly how much memory is allocated on heap we can use valgrind tool and execute our executable. But how can we do it programmatically?Yes, you are correct, programmatically, and it is not difficult as you think and it is very much easy and fast compare to valgrind (I agree it is not much efficient as valgrind) but it servers our purpose.Let’s stop the story and dig into example. In order to track the heap allocation we need to overload two operator’s of the class which needs to be tracked. That is new operator delete operatorAlso in order to track allocation of all the objects we need to have static variable since static variable does not belongs to any object.That’s all you need to do. Now let’s see with full implemented example#include &amp;lt;iostream&amp;gt;class Animal{public: void* operator new (size_t size) { std::cout &amp;lt;&amp;lt; &quot;Inside new operator \\n&quot;; m_size += size; return malloc(size); } void operator delete (void* ptr) { std::cout &amp;lt;&amp;lt; &quot;Inside delete operator \\n&quot;; if (ptr) { m_size -= sizeof(*((Animal*)ptr)); free(ptr); } } Animal() { std::cout &amp;lt;&amp;lt; &quot;Ctor called \\n&quot;; } ~Animal() { std::cout &amp;lt;&amp;lt; &quot;Dtor called \\n&quot;; } static long getHeapAllocation() { return m_size; }private: int m_height = 0; int m_weight = 0; static long m_size;};long Animal::m_size = 0;int main(){ Animal* p = new Animal; std::cout &amp;lt;&amp;lt; &quot;1 - &quot; &amp;lt;&amp;lt; p-&amp;gt;getHeapAllocation() &amp;lt;&amp;lt; &quot;\\n&quot;; Animal* q = new Animal; std::cout &amp;lt;&amp;lt; &quot;2 - &quot; &amp;lt;&amp;lt; q-&amp;gt;getHeapAllocation() &amp;lt;&amp;lt; &quot;\\n&quot;; delete p; std::cout &amp;lt;&amp;lt; &quot;3 - &quot; &amp;lt;&amp;lt; p-&amp;gt;getHeapAllocation() &amp;lt;&amp;lt; &quot;\\n&quot;; delete q; std::cout &amp;lt;&amp;lt; &quot;4 - &quot; &amp;lt;&amp;lt; q-&amp;gt;getHeapAllocation() &amp;lt;&amp;lt; &quot;\\n&quot;; return 0;}Output:bhavith@bhavith:$ ./a.out Inside new operator Ctor called 1 - 8Inside new operator Ctor called 2 - 16Dtor called Inside delete operator 3 - 8Dtor called Inside delete operator 4 - 0Here we can see how memory is allocating and de-allocating.Now let’s see user forget to delete pointer q. Now how can we find how much memory is allocated and freed. For that let’s alter a program and keep track of itUpdate code#include &amp;lt;iostream&amp;gt;// Track the number of bytes allocated on heap sectionclass Animal{public: void* operator new (size_t size) { m_allocation += size; return malloc(size); } void operator delete (void* ptr) { if (ptr) { m_deallocation += sizeof(*((Animal*)ptr)); free(ptr); ptr = nullptr; } } static void checkMemoryLeakage() { std::cout &amp;lt;&amp;lt; &quot;\\n&quot;; std::cout &amp;lt;&amp;lt; &quot;--------------------------------------\\n&quot;; if (m_allocation &amp;gt; m_deallocation) { std::cout &amp;lt;&amp;lt; &quot;==== &quot; &amp;lt;&amp;lt; m_allocation - m_deallocation &amp;lt;&amp;lt; &quot; byte(s) leaked ====\\n&quot;; } else { std::cout &amp;lt;&amp;lt; &quot;No memory leaks found !\\n&quot;; } std::cout &amp;lt;&amp;lt; &quot;--------------------------------------\\n&quot;; }private: int m_height = 0; int m_weight = 0; static long m_allocation; static long m_deallocation;};long Animal::m_allocation = 0;long Animal::m_deallocation = 0;#define CHECK_MEMORY_LEAKS Animal::checkMemoryLeakage();int main(){ Animal* p = new Animal; Animal* q = new Animal; delete p; delete q; CHECK_MEMORY_LEAKS; return 0;}As you can see, just we need to add a macro CHECK_MEMORY_LEAKS before return. I agree this not only the place, also we can use handler as soon as program exit’s and do memory checks there as well.let’ see the output when no memory leaksbhavith@bhavith:$ ./a.out --------------------------------------No memory leaks found !--------------------------------------Now let try commenting the delete q and see the outputint main(){ Animal* p = new Animal; Animal* q = new Animal; delete p; // delete q; -&amp;gt; memory leak CHECK_MEMORY_LEAKS; return 0;}Output:bhavith@bhavith:$ ./a.out --------------------------------------==== 8 byte(s) leaked ====--------------------------------------Here we can see 8 bytes are not freed.Is it not look simple to implement your own valgrind. Yes right?" }, { "title": "Rule of three in c++", "url": "/posts/rule-of-three/", "categories": "c++", "tags": "c++, cpp, modern-c++", "date": "2022-06-16 23:05:00 +0530", "snippet": "There are three special functions in C++ class destructor copy constructor overload assignment operatorIf one of these functions is not defined by programmer, then compiler defines it for you with default behaviorWhat are those default behaviors destructor - It calls destructor of the member variables copy constructor - Copy states of other object to this class and do shallow copy that means, if pointer is the state of other object, then it copies the pointer and doesn’t create a new pointer and copy the content overload assignment operator - It is similar to copy constructorIf class has a pointer, then we have to follow this rule of thumb and define all of these three member function explicitly, So that we can avoid shallow copyLet’s see with exampleenum class Color { Red, Black, Silver, Invalid};const char* colorToStr(const Color&amp;amp; color){ switch (color) { case Color::Black: return &quot;Black&quot;; case Color::Red: return &quot;Red&quot;; case Color::Silver: return &quot;Silver&quot;; case Color::Invalid: default: return &quot;Invalid Color&quot;; }}class Car {public: Car() { std::cout &amp;lt;&amp;lt; &quot;Default ctor called \\n&quot;; m_pColor = new Color(Color::Invalid); } Car(const Color&amp;amp; color) { std::cout &amp;lt;&amp;lt; &quot;Parameterized ctor called \\n&quot;; m_pColor = new Color(color); } ~Car() { std::cout &amp;lt;&amp;lt; &quot;Dtor called \\n&quot;; if (m_pColor) { delete m_pColor; } } Car(const Car&amp;amp; other) { std::cout &amp;lt;&amp;lt; &quot;Copy ctor called \\n&quot;; if (other.m_pColor) { m_pColor = new Color(*other.m_pColor); } } void operator=(const Car&amp;amp; other) { std::cout &amp;lt;&amp;lt; &quot;Overload assignment operator called \\n&quot;; if (other.m_pColor) { if (m_pColor) { *m_pColor = *other.m_pColor; } } } void displayColor() const { if (m_pColor) { std::cout &amp;lt;&amp;lt; &quot;Car color is &quot; &amp;lt;&amp;lt; colorToStr(*m_pColor) &amp;lt;&amp;lt; &quot;\\n&quot;; } }private: Color* m_pColor;};int main(){ Car blackCar(Color::Black); // Parameterized ctor called Car anotherBlackCar = blackCar; //Copy ctor called also `Car anotherBlackCar(blackCar);` is valid syntax Car thirdBlackCar; // Default ctor called thirdBlackCar = anotherBlackCar; // overload assignment operator is called blackCar.displayColor(); anotherBlackCar.displayColor(); thirdBlackCar.displayColor(); return 0;}Output:bhavith@bhavith:$ g++ hello.cppbhavith@bhavith:$ ./a.out Parameterized ctor called Copy ctor called Default ctor called Overload assignment operator called Car color is BlackCar color is BlackCar color is BlackDtor called Dtor called Dtor calledIn the above example we can see, Car has a member variable as a pointer to Color enum class, So according to rule of three, We have to define destructor, copy constructor and overload assignment operator so that we can do deep copy.What if we use RAII for example shared pointer as a member variable?In such case we can have only rule of two, that is copy constructor and overload assignment operator and destructor is uselessExampleenum class Color { Red, Black, Silver, Invalid};const char* colorToStr(const Color&amp;amp; color){ switch (color) { case Color::Black: return &quot;Black&quot;; case Color::Red: return &quot;Red&quot;; case Color::Silver: return &quot;Silver&quot;; case Color::Invalid: default: return &quot;Invalid Color&quot;; }}class Car {public: Car() { std::cout &amp;lt;&amp;lt; &quot;Default ctor called \\n&quot;; m_pColor = std::make_shared&amp;lt;Color&amp;gt;(Color::Invalid); } Car(const Color&amp;amp; color) { std::cout &amp;lt;&amp;lt; &quot;Parameterized ctor called \\n&quot;; m_pColor = std::make_shared&amp;lt;Color&amp;gt;(color); } ~Car() { std::cout &amp;lt;&amp;lt; &quot;Dtor called \\n&quot;; } Car(const Car&amp;amp; other) { std::cout &amp;lt;&amp;lt; &quot;Copy ctor called \\n&quot;; if (other.m_pColor) { m_pColor = other.m_pColor; } } void operator=(const Car&amp;amp; other) { std::cout &amp;lt;&amp;lt; &quot;Overload assignment operator called \\n&quot;; if (other.m_pColor) { if (m_pColor) { m_pColor = other.m_pColor; } } } void displayColor() const { if (m_pColor) { std::cout &amp;lt;&amp;lt; &quot;Car color is &quot; &amp;lt;&amp;lt; colorToStr(*m_pColor) &amp;lt;&amp;lt; &quot;\\n&quot;; } } void refCnt() const { std::cout &amp;lt;&amp;lt; &quot;Ref count is &quot; &amp;lt;&amp;lt; m_pColor.use_count() &amp;lt;&amp;lt; &quot;\\n&quot;; }private: std::shared_ptr&amp;lt;Color&amp;gt; m_pColor;};int main(){ Car blackCar(Color::Black); // Parameterized ctor called blackCar.refCnt(); // 1 Car anotherBlackCar = blackCar; //Copy ctor called anotherBlackCar.refCnt(); // 2 since copied Car thirdBlackCar; // Default ctor called thirdBlackCar.refCnt(); // 1 thirdBlackCar = anotherBlackCar; // overload assignment operator is called thirdBlackCar.refCnt(); // 3 since copied blackCar.displayColor(); anotherBlackCar.displayColor(); thirdBlackCar.displayColor(); return 0;}Output:bhavith@bhavith:$ g++ hello.cppbhavith@bhavith:$ ./a.out Parameterized ctor called Ref count is 1Copy ctor called Ref count is 2Default ctor called Ref count is 1Overload assignment operator called Ref count is 3Car color is BlackCar color is BlackCar color is BlackDtor called Dtor called Dtor called Note: Observer how reference counts are increasing, It is also a shallow copy, but the life time of the shared pointer is when last object is destructed. That is the beauty of smart pointers" }, { "title": "Single Responsibility Principle", "url": "/posts/single-responsibility-principle/", "categories": "design-pattern", "tags": "c++, cpp, design-pattern", "date": "2022-06-13 07:57:00 +0530", "snippet": "There are five design principles and one among them is SRP (Single Responsibility Principle). it stated that Every class should have only one reason to changeWhat does it means the only one reason to change? When ever we see this statement it sound simple but very much confused.Suppose I have a class and I want do modify it, At that particular moment, I have only one reason to change it and I am doing it what’s the problem and what’s the big deal?That is where many people get confused. In order to make it simple, let me rephrase it in another way. A class should be created to do only one kind of job not many, So that, that class is expertize in doing that particular job.As a real life example each individual is expert in one thing. For example plumber is very good in repairing the taps, TV repair guy know how to repair a TV. But plumber can learn the TV repair and he can repair the TV, but nobody believes plumber and give their TV to repair.Similarly in OOPs its better to make a class expert in one thing.Let’s see the exampleclass Person{public: void repairTap(); void repairTelevision();};Now in this above example, we can see Person is doing two jobs and it breaks the SRP (Single Responsibility Principle). Its better to break and Person class into two classes namely Plumber and TVTechnician so each classes are expert in there own field.New exampleclass Plumber{public: void repairTap(); void repairValve(); void fixPipeline();};class TVTechnician{public: void repairTelevision(); void fixTelevisionDisplay();};The splitting of the classes into their respective job is called separation of concernSo, if we want to change the class Plumber my main reason or intent is to do something with plumping not with TV. That is your single reason to update the class.Now, let see one more real time example.class Document{public: Document(const std::string&amp;amp; name) : m_name(name) { } void write(const std::string content) { m_content = content; } std::string read() const { return m_content; } void save(const std::string&amp;amp; fileName) { std::ofstream f(fileName, std::ofstream::out); if (f.is_open()) f &amp;lt;&amp;lt; m_content &amp;lt;&amp;lt; &quot;\\n&quot;; }private: std::string m_name = &quot;Untitled&quot;; std::string m_content = &quot;&quot;;};int main(){ Document d(&quot;Resume&quot;); d.write(&quot;This is my resume&quot;); d.save(&quot;resume.txt&quot;); return 0;}Outputbhavith@bhavith:$ g++ hello.cpp bhavith@bhavith:$ ./a.out bhavith@bhavith:$ cat resume.txt This is my resumeIn the above example we can see that Document class is trying to do two jobs Operations w.r.t documents i.e. setting the name, writing and reading Operations w.r.t to saving the documentsSince Document class is doing two jobs it is breaking SRP.Suppose in future if we want to add one more function called saveAsPdf then we are keep on adding those kind of functionalities to Document and again it’s breaking the SRP.The better way is to split the Document class into two, and make two experts to do their respective job correctly. One can be Document and another class can be PersistentManagerLet’s see how new example looks now#include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;fstream&amp;gt;class Document{public: Document(const std::string&amp;amp; name) : m_name(name) { } void write(const std::string content) { m_content = content; } std::string read() const { return m_content; }private: std::string m_name = &quot;Untitled&quot;; std::string m_content = &quot;&quot;;};class PersistentManager{public: void save(const Document&amp;amp; doc, const std::string&amp;amp; fileName) { save(DocumentType::TXT, doc, fileName); } void saveAsPdf(const Document&amp;amp; doc, const std::string&amp;amp; fileName) { save(DocumentType::PDF, doc, fileName); }private: enum class DocumentType {TXT, PDF,}; void save(const DocumentType docType, const Document&amp;amp; doc, const std::string&amp;amp; fileName) const { std::string fileNameWithExtension = fileName; switch (docType) { case DocumentType::PDF: fileNameWithExtension += &quot;.pdf&quot;; break; case DocumentType::TXT: fileNameWithExtension += &quot;.txt&quot;; break; default: break; } std::ofstream f(fileNameWithExtension, std::ofstream::out); if (f.is_open()) f &amp;lt;&amp;lt; doc.read() &amp;lt;&amp;lt; &quot;\\n&quot;; }};int main(){ PersistentManager pm; Document doc(&quot;Resume&quot;); doc.write(&quot;This is my resume&quot;); pm.save(doc, &quot;resume&quot;); pm.saveAsPdf(doc, &quot;resume&quot;); return 0;}Output:bhavith@bhavith:$ g++ hello.cpp bhavith@bhavith:$ ./a.out bhavith@bhavith:$ cat resume.txt This is my resumebhavith@bhavith:$ cat resume.pdf This is my resumeCan you see now, how the responsibility is split into two. Now you have only one reason or having one expert to do better job.That is all about Single Responsibility Principle" }, { "title": "C++ concepts covered most", "url": "/posts/c-notes/", "categories": "c++ or cpp", "tags": "c++, cpp, pointers", "date": "2022-06-04 00:15:00 +0530", "snippet": "Inheritance It is a relation ship between two classes where one class child inherit from other class parent Polymorphism Single entity can exist in two different forms Example: function overloading - two function exist with same name virtual functions operator overloading Encapsulation Mechanism by which data and functions are packed together into a single unit called class It provide data security Abstraction Representing the necessary details without including the background details which are not needed for presentation Helps in reducing the complexities in understanding the unnecessary details Example: STL Access specifiers Public: Data members and member function can be accessed any where in the program Private: Data members and member functions can only be accessed with this object. That is only member function can access data member Protected: Can be accessed only by the member function and friends of the class, Also it can be accessed by child member function and friends derived from that classInitialization of the variablesint a = 10;int a(10);This pointerclass Test{public: // compiler changes to // void display(Test* const this, const std::string&amp;amp; name) void display(const std::string&amp;amp; name) { std::cout &amp;lt;&amp;lt; &quot;name is &quot; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &quot;\\n&quot;; // compiler changes to //std::cout &amp;lt;&amp;lt; &quot;name is &quot; &amp;lt;&amp;lt; this-&amp;gt;name &amp;lt;&amp;lt; &quot;\\n&quot;; }};int main(){ Test t; t.display(&quot;Bhavith&quot;); // compiler changes to // display(&amp;amp;t, &quot;Bhavith&quot;); Test* p = new Test; p-&amp;gt;display(&quot;Bhavith&quot;); // compiler changes to // display(p, &quot;Bhavith&quot;)}Types of member functionsNested member functionsclass Test{public: void setData(int a) { m_a = a; display(); // nested memeber function } void display() { std::cout &amp;lt;&amp;lt; m_a &amp;lt;&amp;lt; &quot;\\n&quot;; } int getData() { display(); // nested member function return m_a; }private: int m_a;};Overloaded member functionclass Attitude{public: void display(void); void display(int); // overloaded function};Overloaded member function of two different classesclass Attitude1{public: void display();};class Attitude2{public: void display();};In above example both Attitude1 and Attitude2 has function display with same prototype and it is completely validMember function with default argumentclass Test(){public: int add(int a, int b = 20) { return a + b; }};int main(){ Test t; t.add(1, 2); // return 3 t.add(1); // return 1 + 20 i.e. 21}Note: default argument should always starts from the right side of the function and cannot come in between or start of the functionInline member functionCan define outside the classclass Test{public: int add (int a, in b);};inline int Test::add(int a, int b){ return a + b;}Can define inside the class -&amp;gt; but it is by default inlineclass Test{public: int add(int a, int b) // Automatically inline { return a + b; }} It is request to the compiler and a command It can be added only to a small function It pushes argument to the stack, saves various registers etc.Constant member functionsIt is kind of a function which denied permission to change the value of the data membersclass Test{public: // compiler changes to // void increment(const Test* const this) // In above line value is also a constant so we cannot modifies it void increment() const { m_value++; // not allowed // compiler // this-&amp;gt;m_value; // not allowed because it is a const // But there is hack we can do i.e. ((Test*)this)-&amp;gt;m_value++; // here we are typecasting the const this pointer to non const this pointer and accessing it }private: int m_value;};int main(){ Test t; t.increment();}There are three important concepts which we need to understand constant data member Member whose value cannot be changed throughout the execution of the program Key points: In C const is a global that means it can be accessed in other file, if we want to make them local then prefix with static keyword In C++ const is a local variable to that file and it cannot be accessed by any other file so explicit static is not required In C++ const variables must be initialized during the creation other wise compiler throws error const int SIZE = 25;int arr[SIZE]; // allowed in C++ not in C Mutable data member If data member if prefixed with mutable key word then const member function can modify such data member class Test{public: void increment() const { m_value++; // allowed since m_value is mutable }private: mutable int m_value;}; Static data member It is not owned by any object of a class, but it is essentially a data member of a class There is only one copy of a static data member created for a class which can be accessed by all the object of that class Scope of the static member is within a class, but its lifetime is the entire program Static data member is initialized to zero when it is created, static variables are used to maintain values common to the entire class Static data members does not form a class size. This is because the static data member are created separately and not when the object is created. Static Member functions It is used to access or modify the static members (functions or variables) It can be called without using an existing object using scope resolutionclass Test{public: static void update() { m_value = m_value + 10; }private: static int m_value;};int main(){ Test::update(); // No need to create an instance directly we can call it return 0;}Array of class Objectsclass Test{public: void set(int value) { m_value = value; } int get() const { return m_value; }private: int m_value;};int main(){ Test t[2]; for (int i = 0; i &amp;lt; 2; i++) { t[i].set(10); std::cout &amp;lt;&amp;lt; t[i].get() &amp;lt;&amp;lt; &quot;\\n&quot;; } Test* p = new Test[2]; delete[] p; // dont forget to use delete[] not delete return 0;}Passing objects to functionsPassing objects by value Here only a copy of the object is passed to a function, changes made to that copy will not reflect into the object which is calling Passing objects by reference Here changes made to the object sent via function is reflected in the object which is calling Passing objects by pointer Change of the object in the called function will be reflected in the calling functionclass Test{public: int a; void set(Test t, int value) { t.a = value; } void set(int value, Test&amp;amp; t) { t.a = value; } void set(Test* p, int value) { p-&amp;gt;a = value; }};int main(){ Test t; t.a = 10; t.set(t, 11); std::cout &amp;lt;&amp;lt; &quot;pass by value &quot; &amp;lt;&amp;lt; t.a &amp;lt;&amp;lt; &quot;\\n&quot;; t.set(12, t); std::cout &amp;lt;&amp;lt; &quot;pass by reference &quot; &amp;lt;&amp;lt; t.a &amp;lt;&amp;lt; &quot;\\n&quot;; t.set(&amp;amp;t, 100); std::cout &amp;lt;&amp;lt; &quot;pass by pointer &quot; &amp;lt;&amp;lt; t.a &amp;lt;&amp;lt; &quot;\\n&quot;;}Dynamic memory allocationclass Test{};int main(){ Test* p = new Test; // allocation if (p) { delete p; // deallocation } // Array Test* q = new Test[10]; // allocation of array if (q) { delete[] q; // deallocation of array }}When ever heap is full then pointer returns nullptr. This can be checked using set_new_handler function which is declared in #include &amp;lt;new&amp;gt; headerExample:#include &amp;lt;iostream&amp;gt;#include &amp;lt;new&amp;gt;#include &amp;lt;cstdlib&amp;gt;void my_handler(){ std::cout &amp;lt;&amp;lt; &quot;Memory exhaused !!!\\n&quot;; exit(EXIT_FAILURE);}int main(){ set_new_handler(my_handler); while (1) { int* p = new int[1000000]; } return 0;}Constructors and DestructorsConstructor Member function of a class, whose name is same as class name Task is to initialize the data member for an object of a class automatically, when an object of the same class is created No return type for it Can be overloaded Cannot be a virtual functionTypes Default constructor Parameterized constructor When parameterized constructer is defined then compiler will not add default constructor we need to create on explicitly Parameterized dynamic constructor Overloaded constructors Constructors with default value Copy constructors Inheritance Deriving from existing class publicly Base class Derived class private will not be inherited public will be public protected will be protected Deriving from the existing class protected ly Base class Derived class private will not be inherited public will be protected protected will be protected Deriving from the existing class privately Base class Derived class private will not be inherited public will be private protected will be private Important points ⭐ - Constructors are not inherited but can be called from the derived class![[single-inheritance.svg]]Overridingstruct A{ void display() { std::cout &amp;lt;&amp;lt; &quot;Display of A \\n&quot;; }};struct B : public A{ void display() { std::cout &amp;lt;&amp;lt; &quot;Display of B \\n&quot;; }};int main(){ A a; a.display(); // Display of A because left side is a a.B::display(); // compilation error left side parent and it is a B b; b.display(); // Display of B because left side is b b.A::display(); // Display of A because scope resolution is used A* ap = new A; ap-&amp;gt;display(); // Display of A becaus left side is A ap-&amp;gt;B::display(); // compilation error left side is parent and B is not yet created B* bp = new B; bp-&amp;gt;display(); // Display of B because left side of B pointer bp-&amp;gt;A::display(); // Display of A because scope resolution is used to call parent display A* p = new B; p-&amp;gt;display(); // Display of A because no virtual function and left side is A pointer p-&amp;gt;B::display(); // Compilation error because left side pointer is A type}Virtual function and polymorphism Compile time polymorphism function overloading operator overloading Run time polymorphism virtual functions How virtual functions work internally During compile time a virtual table (VTBL) is created both for base class and derived class. This table contains only the addresses of virtual function in the corresponding class Addresses of non virtual functions is not present in VTBLExample class A{public: virtual void xyz(); virtual void pqr();}; During run time, the VTBL of the base class contains all the addresses of the functions xyz() and pqr() as shown below![[Base A.svg]]Second, let us consider the VTBL of the derived class class B : public A{public: void pqr(); virtual void jkl();}; If the derived class contains an overriding function, then the VTBL of the derived class contains a new address for the overriding function. If a derived class declares a new virtual functions, its VTBL contains the address of the new virtual function. If the derived class does not redefine a certain base class virtual function, then the VTBL of the derived class will contain the address of the inherited base class function itself![[Base B.svg]]Whenever a virtual function is called, the value of VPTR is read first, then the address of the called function is obtained from the VTBLSize of the object of classed with virtual function increases uniformly by four or eight bytes depends on architecture due to presence of additional pointer.#include &amp;lt;iostream&amp;gt;#pragma pack(1)class A{public: virtual void xyz() { std::cout &amp;lt;&amp;lt; &quot;xyz of A \\n&quot;; } virtual void pqr() { std::cout &amp;lt;&amp;lt; &quot;pqr of A\\n&quot;; }};#pragma pack(1)class B : public A{public: void pqr() { std::cout &amp;lt;&amp;lt; &quot;pqr of B \\n&quot;; } void jkl() { std::cout &amp;lt;&amp;lt; &quot;jkl of B\\n&quot;; }};int main(){ A* ap = new A; // VTBL with VPTR is created for A ap-&amp;gt;xyz(); // xyz of A ap-&amp;gt;pqr(); // pqr of A B* bp = new B(); // VTBL with VPTR is created for B bp-&amp;gt;xyz(); // xyz of A bp-&amp;gt;pqr(); // pqr of B bp-&amp;gt;jkl(); // jkl of B A* p = new B; // VTBL with VPTR is created for B p-&amp;gt;pqr(); // pqr of B return 0;}Outputxyz of A pqr of Axyz of A pqr of B jkl of Bpqr of B Virtual destructorclass A{public: A() { std::cout &amp;lt;&amp;lt; &quot;A Ctor called \\n&quot;; } ~A() { std::cout &amp;lt;&amp;lt; &quot;A Dtor called \\n&quot;; }};class B : public A{public: B() { std::cout &amp;lt;&amp;lt; &quot;B Ctor called \\n&quot;; } ~B() { std::cout &amp;lt;&amp;lt; &quot;B Dtor called \\n&quot;; }};int main(){ B* bp = new B; delete bp; // A Ctor -&amp;gt; B Ctor -&amp;gt; B Dtor -&amp;gt; A Dtor A* ap = new A; delele ap; // A Ctor -&amp;gt; A Dtor A* p = new B; delete p; // A Ctor -&amp;gt; B Ctor -&amp;gt; A Dtor // Here is the problem there is not B Dctor called it is compile time resolution there we need to put virtual for Dtor then it works}Early Binding Vs Late BindingEarly Binding (Static Binding) compiler binds function call and the appropriate function definition at compile time function overloading operator overloading Late binding (dynamic binding) function call and the appropriate function definition is bind at run time this can be achieved by using virtual functions There are run time performance overheadOperator OverloadingWe can overload Unary operators (operating on one operand) Binary operators (operating on two operands) Special operators ([], (), etc)Operators that cannot be overloaded operator symbol 1. Scope resolution operator :: 2. Member selection operator . 3. Member selection through pointer to member operator .* 4. Conditional operator ?: 5. size of operator sizeof 6. typeid operator typeid Operators that can be overloaded # Name symbols 1 Binary arithmetic +, -, *, /, % 2 Unary Arithmetic +, -, ++,-- 3 Assignment =,+=,*=, /=,-=,%=,&amp;amp;=,|=,^= 4 Bit wise &amp;amp;, \\|,!,&amp;gt;&amp;gt;,&amp;lt;&amp;lt;,~,^ 5 Dereferencing -&amp;gt; 6 Dynamic memory allocation and deallocation new, delete 7 Subscript [] 8 Function call () 9 Logical &amp;amp;&amp;amp;, ||,! 10 Relational &amp;gt;,&amp;lt;,==,!=,&amp;lt;=,&amp;gt;= 11 Others &amp;gt;&amp;gt;=,&amp;lt;&amp;lt;= Unary operator syntax&amp;lt;return-type&amp;gt; &amp;lt;class_name&amp;gt;:: operator opr (){ // operator function definition}// Exampleclass Test{public: void operator - () { // `-` is overloaded } void operator + () { // `+` is overloaded }};Binary operator syntax&amp;lt;return-type&amp;gt; &amp;lt;class_name&amp;gt;:: operator opr(&amp;lt;argument1&amp;gt;) // only one argument{ // function defintion}// Exampleclass Test{public: void operator + (Test&amp;amp; t) { // `+` is overloaded } void operator - (Test&amp;amp; t) { // `-` is overloaded }};Important overloaded operators which is used frequentlyOverloading &amp;lt;&amp;lt; and &amp;gt;&amp;gt; operator#include &amp;lt;iostream&amp;gt;class Point{public: Point(int x, int y) : m_x(x), m_y(y) { } ~Point() { m_x = 0; m_y = 0; } friend std::ostream&amp;amp; operator &amp;lt;&amp;lt; (std::ostream&amp;amp; out, const Point&amp;amp; point) { out &amp;lt;&amp;lt; &quot;x = &quot; &amp;lt;&amp;lt; point.m_x &amp;lt;&amp;lt; &quot;, y = &quot; &amp;lt;&amp;lt; point.m_y; return out; } friend std::istream&amp;amp; operator &amp;gt;&amp;gt; (std::istream&amp;amp; in, Point&amp;amp; point) { in &amp;gt;&amp;gt; point.m_x &amp;gt;&amp;gt; point.m_y; return in; }private: int m_x; int m_y;};int main(){ Point p(10, 20); std::cin &amp;gt;&amp;gt; p; std::cout &amp;lt;&amp;lt; p &amp;lt;&amp;lt; &quot;\\n&quot;;}Overloading new and delete operatorSyntax://Newclass &amp;lt;class_nam&amp;gt;{public: void* operator new (size_t) { // defintion }};// New arrayclass &amp;lt;class_name&amp;gt;{public: void* operator new [](size_t) { // definition }};// deleteclass &amp;lt;class_name&amp;gt;{public: void operator delete(void*) { }};// delete arrayclass &amp;lt;class_name&amp;gt;{public: void operator delete[] (void*) { }};Examples:#include &amp;lt;iostream&amp;gt;class Point{public: void* operator new (size_t size) { std::cout &amp;lt;&amp;lt; &quot;Allocating memory\\n&quot;; void* p = ::operator new(size); return p; } void* operator new [] (size_t size) { std::cout &amp;lt;&amp;lt; &quot;Allocating memory for array\\n&quot;; void* p = ::operator new[](size); return p; } void operator delete (void* p) { std::cout &amp;lt;&amp;lt; &quot;Deleting pointer \\n&quot;; if (p) { ::operator delete(p); } } void operator delete [] (void* p) { std::cout &amp;lt;&amp;lt; &quot;Deleting pointer array\\n&quot;; if (p) { ::operator delete[](p); } } Point() { std::cout &amp;lt;&amp;lt; &quot;Ctor\\n&quot;; } Point(int x, int y) : m_x(x), m_y(y) { std::cout &amp;lt;&amp;lt; &quot;Ctor\\n&quot;; } ~Point() { std::cout &amp;lt;&amp;lt; &quot;Dtor\\n&quot;; m_x = 0; m_y = 0; }private: int m_x; int m_y;};int main(){ Point* p = new Point(10, 20); delete p; Point* pArr = new Point[2]; delete[] pArr;}Overloading [] operatorExample#include &amp;lt;iostream&amp;gt;class Array{public: Array() { for (int i = 0; i &amp;lt; 10; i++) { m_arr[i] = i + 1; } } int operator [](int index) { std::cout &amp;lt;&amp;lt; &quot;Indexing ..\\n&quot;; if (index &amp;lt; 0 || index &amp;gt;= 10) { return -1; } return m_arr[index]; }private: int m_arr[10];};int main(){ Array arr; std::cout &amp;lt;&amp;lt; arr[8] &amp;lt;&amp;lt; &quot;\\n&quot;;}Overloading = operatorExample:#include &amp;lt;iostream&amp;gt;class Point{public: Point(int x, int y) : m_x(x), m_y(y) { } Point(const Point&amp;amp; other) { std::cout &amp;lt;&amp;lt; &quot;Copy ctor invoked\\n&quot;; m_x = other.m_x; m_y = other.m_y; } void operator = (const Point&amp;amp; other) { std::cout &amp;lt;&amp;lt; &quot;= operator invoked\\n&quot;; m_x = other.m_x; m_y = other.m_y; } void print() { std::cout &amp;lt;&amp;lt; &quot;x = &quot; &amp;lt;&amp;lt; m_x &amp;lt;&amp;lt; &quot;, y = &quot;&amp;lt;&amp;lt; m_y &amp;lt;&amp;lt; &quot;\\n&quot;; }private: int m_x; int m_y;};int main(){ Point p1(10, 20); Point p2 = p1; // copy ctor p2.print(); Point p3 (p1); // copy ctor p3.print(); Point p4(100, 200); p1 = p4; // = operator is called p1.print(); return 0;}Overloading () operatorExample#include &amp;lt;iostream&amp;gt;class Point{public: Point(int x, int y) : m_x(x), m_y(y) { } void operator()(int x , int y) { std::cout &amp;lt;&amp;lt; &quot;Paramertized opertor () is called \\n&quot;; m_x = x; m_y = y; print(); } void operator ()() { std::cout &amp;lt;&amp;lt; &quot;Opertor () is called \\n&quot;; print(); } void print() { std::cout &amp;lt;&amp;lt; &quot;x = &quot; &amp;lt;&amp;lt; m_x &amp;lt;&amp;lt; &quot;, y = &quot;&amp;lt;&amp;lt; m_y &amp;lt;&amp;lt; &quot;\\n&quot;; }private: int m_x; int m_y;};int main(){ Point p(10, 20); p(); p(100, 200); return 0;}Order of invocationIf we have 1 child class inherited from two base class then constructor is called on the order of inheritance not in order of invocationclass Derived : public Base1, public Base2- Base1 ctor called- Base2 ctor called- Derived Ctor calledExample:#include &amp;lt;iostream&amp;gt;class Base1{public: Base1() { std::cout &amp;lt;&amp;lt; &quot;Base 1 ctor called \\n&quot;; }};class Base2{public: Base2() { std::cout &amp;lt;&amp;lt; &quot;Base 2 ctor called\\n&quot;; }};class Derived : public Base2, public Base1{public: Derived() : Base1(), Base2() { std::cout &amp;lt;&amp;lt; &quot;Derived ctor called \\n&quot;; }};int main(){ Derived d; return 0;}OutputBase 2 ctor calledBase 1 ctor called Derived ctor called Event though we invoked Base1 constructor in Derived constructor, Ctor called in order of inheritanceOrder of invocation virtual inheritanceIn case of virtual inheritance, virtual class constructor will be called first, then order of inheritanceExampleclass Derived : public Base2, public Base1, virtual public Base3- Base3 ctor called- Base2 ctor called- Base1 ctor called- Derived ctor calledexample:#include &amp;lt;iostream&amp;gt;class Base1{public: Base1() { std::cout &amp;lt;&amp;lt; &quot;Base 1 ctor called \\n&quot;; }};class Base2{public: Base2() { std::cout &amp;lt;&amp;lt; &quot;Base 2 ctor called\\n&quot;; }};class Base3{public: Base3() { std::cout &amp;lt;&amp;lt; &quot;Base 3 ctor called\\n&quot;; }};class Derived : public Base2, public Base1, virtual public Base3{public: Derived() : Base1(), Base2() { std::cout &amp;lt;&amp;lt; &quot;Derived ctor called \\n&quot;; }};int main(){ Derived d; return 0;}OutputBase 3 ctor calledBase 2 ctor calledBase 1 ctor called Derived ctor called Type conversion conversion from basic type to class type conversion from class type to basic type conversion from one class type to another class typeConversion from basic type to class type#include &amp;lt;iostream&amp;gt;class Test{public: Test() { } Test(int value) : m_value(value) // constructor performing conversion { std::cout &amp;lt;&amp;lt; &quot;Parmeterized ctor is invoked \\n&quot;; } void display() { std::cout &amp;lt;&amp;lt; &quot;value = &quot; &amp;lt;&amp;lt; m_value &amp;lt;&amp;lt; &quot;\\n&quot;; }private: int m_value;};int main(){ Test t; t = 10; t.display(); return 0;}OutputParmeterized ctor is invoked value = 10Here t = 10; compiler try to find operator = it did not find anything then it finds the parametrized constructor and which can take int so it called that and compiler converts 10 to class type TestConversion from class type to basic type#include &amp;lt;iostream&amp;gt;class Test{public: Test(int value) : m_value(value) { } operator int() // this does the conversion { return m_value; } void display() { std::cout &amp;lt;&amp;lt; &quot;value = &quot; &amp;lt;&amp;lt; m_value &amp;lt;&amp;lt; &quot;\\n&quot;; }private: int m_value;};int main(){ Test t(10); int x = t; std::cout &amp;lt;&amp;lt; &quot;x = &quot; &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &quot;\\n&quot;; return 0;}Outputx = 10There are some rules to be remember when overloading the typesFirst syntax:opertor type(){ return &amp;lt;type value&amp;gt;;}Rules: - It must have no arguments - It must be a class member function - It must not specify a return type but should return a valueConversion from class type to class typeUsing parametrized constructor#include &amp;lt;iostream&amp;gt;class B{public: int getValue() { return m_valueOfB; }private: int m_valueOfB = 100;};class A{public: A(B&amp;amp; b) // constructor converting the object of other type { std::cout &amp;lt;&amp;lt; &quot;Calling conversion \\n&quot;; m_value = b.getValue(); } A() { } ~A() { } void display() { std::cout &amp;lt;&amp;lt; &quot;value = &quot; &amp;lt;&amp;lt; m_value &amp;lt;&amp;lt; &quot;\\n&quot;; }private: int m_value = -1;};int main(){ A a; B b; a = b; // here it should have called operator = but since it is not there it has choose paramterized ctor a.display(); return 0;}OutputCalling conversion value = 100Using type conversion#include &amp;lt;iostream&amp;gt;class B{public: int getValue() { return m_valueOfB; }private: int m_valueOfB = 100;};class A{public: operator B() // contains operator of other class. it is little confusing I know { B temp; m_value = temp.getValue(); return temp; } void display() { std::cout &amp;lt;&amp;lt; &quot;value = &quot; &amp;lt;&amp;lt; m_value &amp;lt;&amp;lt; &quot;\\n&quot;; }private: int m_value = -1;};int main(){ A a; B b; b = a; a.display(); return 0;}Outputvalue = 100explicit 🌟To avoid basic data type to class data type conversion we have to use explicit and it avoid implicit conversion from basic data type to class data type#include &amp;lt;iostream&amp;gt;class A{public: A(int x) { m_value = x; } void display() { std::cout &amp;lt;&amp;lt; &quot;value = &quot; &amp;lt;&amp;lt; m_value &amp;lt;&amp;lt; &quot;\\n&quot;; }private: int m_value = -1;};int main(){ A a = 10; // implicit conversion a.display(); return 0;}Outputvalue = 10How can we avoid it. just by adding explicit key word to parameterized constructorexplicit A(int x){ m_value = x;}Compilation outputC:/Users/bhavi/Documents/learningcpp/main.cpp: In function &#39;int main()&#39;:C:/Users/bhavi/Documents/learningcpp/main.cpp:21:11: error: conversion from &#39;int&#39; to non-scalar type &#39;A&#39; requested 21 | A a = 10; | ^~ninja: build stopped: subcommand failed.19:00:44: The process &quot;C:\\Qt\\Tools\\CMake_64\\bin\\cmake.exe&quot; exited with code 1.Error while building/deploying project learningcpp (kit: Desktop Qt 6.3.0 MinGW 64-bit)When executing step &quot;Build&quot;RUN-TIME TYPE IDENTIFCATION (RTTI)To identify which derived object the base pointer it pointing to C++ uses dynamic_cast and typeidDuring runtime to identify which type of object the base pointer is pointing we call as Run time type identification#include &amp;lt;iostream&amp;gt;#include &amp;lt;typeinfo&amp;gt;int main(){ int a; float b; double c; long d; std::cout &amp;lt;&amp;lt; typeid(a).name() &amp;lt;&amp;lt; &quot;\\n&quot;; std::cout &amp;lt;&amp;lt; typeid(b).name() &amp;lt;&amp;lt; &quot;\\n&quot;; std::cout &amp;lt;&amp;lt; typeid(c).name() &amp;lt;&amp;lt; &quot;\\n&quot;; std::cout &amp;lt;&amp;lt; typeid(d).name() &amp;lt;&amp;lt; &quot;\\n&quot;;}Outputi // means intf // means floatd // means doublel // means longLets check with user defined data type and its derived#include &amp;lt;iostream&amp;gt;#include &amp;lt;typeinfo&amp;gt;class Parent{};class Derived : public Parent{};int main(){ Parent p; Derived d; std::cout &amp;lt;&amp;lt; typeid(p).name() &amp;lt;&amp;lt; &quot;\\n&quot;; std::cout &amp;lt;&amp;lt; typeid(d).name() &amp;lt;&amp;lt; &quot;\\n&quot;;}Output - output depends on OS to OS6Parent7Derived#include &amp;lt;iostream&amp;gt;#include &amp;lt;typeinfo&amp;gt;class Parent{public: void display() { }};class Derived : public Parent{public: void display() { }};int main(){ Parent *p = new Derived; std::cout &amp;lt;&amp;lt; typeid(*p).name() &amp;lt;&amp;lt; &quot;\\n&quot;;}Output:6Parent✨ Here we can see that, since there is no virtual function in Parent class typeid is giving as Parent since the pointer is of Parent typeLet’s see what happen if we add virtual function in Parentvirtual void display(){}Output:7DerivedNow you can see we get Derived. That means typeid is used only for polymorphic classes Final example:#include &amp;lt;iostream&amp;gt;#include &amp;lt;typeinfo&amp;gt;class Parent{public: virtual void display() { }};class Derived : public Parent{public: void display() { }};int main(){ Parent *p = new Parent; Derived *d = new Derived; if (typeid(*p) != typeid(*d)) { std::cout &amp;lt;&amp;lt; &quot;Correct\\n&quot;; } else { std::cout &amp;lt;&amp;lt; &quot;Wrong\\n&quot;; } p = d; if (typeid(*p) == typeid(*d)) { std::cout &amp;lt;&amp;lt; &quot;Correct\\n&quot;; } else { std::cout &amp;lt;&amp;lt; &quot;Wrong\\n&quot;; }}OutputCorrectCorrectWorked as expected !!!Casting operators dynamic_cast operator static_cast operator reinterpret_cast operator const_cast operatordynamic_cast operatorWhen ever we want to convert the base pointer to derived pointer then dynamic_cast is used and it return pointer if success otherwise NULL#include &amp;lt;iostream&amp;gt;#include &amp;lt;typeinfo&amp;gt;class Parent{public: virtual void display() { }};class Derived : public Parent{public: void display() { }};int main(){ Parent* parent; // parent pointer Derived* derived = new Derived; // Derived object parent = derived; // parent can point to derived // I want to take back my pointer from parent, it&#39;s not possible during compile time. Below statement give compilation error //derived = parent; // Use run time casting derived = dynamic_cast&amp;lt;Derived*&amp;gt;(parent); if (derived == NULL) { std::cout &amp;lt;&amp;lt; &quot;Dynamic cast failed\\n&quot;; } else { std::cout &amp;lt;&amp;lt; &quot;Success\\n&quot;; } delete derived;}OutputSuccessstatic_cast operatorit is same as dynamic_cast but does not return any error, If we use it wrong way then it produce undefined behaviourreinterpret_cast operatorIt is same as C type castingint i = 6;int *a = &amp;amp;i;void* p = a;int* q ;q = (int*)p; // C styleq = reinterpret_cast&amp;lt;int*&amp;gt;(p); // C++ style const_cast operatorIf we want to change the value of the member variable in const function then we have following options Make data member as mutable Type cast and remove const -&amp;gt; This is called const cast with syntactical sugar#include &amp;lt;iostream&amp;gt;#include &amp;lt;typeinfo&amp;gt;class Test{public: void increment() const { // type cast myself ((Test*)this)-&amp;gt;m_value++; //Using const cast const_cast&amp;lt;Test*&amp;gt;(this)-&amp;gt;m_value++; } int m_value = 0;};int main(){ Test t; t.increment(); std::cout &amp;lt;&amp;lt; t.m_value &amp;lt;&amp;lt; &quot;\\n&quot;;}Output2TemplatesFunction templatestemplate&amp;lt;class T&amp;gt;return_type &amp;lt;function_name&amp;gt; (paremetees of type T){ // function body}Example#include &amp;lt;iostream&amp;gt;// example 1template&amp;lt;class T&amp;gt;T add(T a, T b){ std::cout &amp;lt;&amp;lt; &quot;using example 1 \\n&quot;; return a + b;}// example 2template&amp;lt;class A, class B&amp;gt;B add(A v1, B v2){ std::cout &amp;lt;&amp;lt; &quot;using example 2 \\n&quot;; return v1 + v2;}// example 3template&amp;lt;class T&amp;gt;T updateBy(T a, int b){ std::cout &amp;lt;&amp;lt; &quot;using example 3 \\n&quot;; return a + b;}int main(){ // example 1 std::cout &amp;lt;&amp;lt; add&amp;lt;int&amp;gt;(10, 20) &amp;lt;&amp;lt; &quot;\\n&quot;; std::cout &amp;lt;&amp;lt; add&amp;lt;double&amp;gt;(10.1, 20.2) &amp;lt;&amp;lt; &quot;\\n&quot;; // example 2 std::cout &amp;lt;&amp;lt; add&amp;lt;int, int&amp;gt;(10, 20) &amp;lt;&amp;lt; &quot;\\n&quot;; std::cout &amp;lt;&amp;lt; add&amp;lt;int, double&amp;gt;(10, 20.2) &amp;lt;&amp;lt; &quot;\\n&quot;; // example 3 std::cout &amp;lt;&amp;lt; updateBy&amp;lt;int&amp;gt;(10, 5) &amp;lt;&amp;lt; &quot;\\n&quot;; std::cout &amp;lt;&amp;lt; updateBy&amp;lt;float&amp;gt;(0.5, 5) &amp;lt;&amp;lt; &quot;\\n&quot;;}Outputusing example 1 30using example 1 30.3using example 2 30using example 2 30.2using example 3 15using example 3 5.5Class Templatestemplate&amp;lt;class T&amp;gt;class class_name{ // class definition };Example#include &amp;lt;iostream&amp;gt;template &amp;lt;class T&amp;gt;class Add{public: T add(T a, T b) { std::cout &amp;lt;&amp;lt; &quot;example 1\\n&quot;; return a + b; }};template &amp;lt;class A, class B&amp;gt;class Point{public: B addCordinates(A a, B b) { std::cout &amp;lt;&amp;lt; &quot;example 2\\n&quot;; return a + b; }};template &amp;lt;class T&amp;gt;class Update{public: int updateBy10(T value, int a = 10) { std::cout &amp;lt;&amp;lt; &quot;example 3\\n&quot;; return value + 10; }};int main(){ // example 1 Add&amp;lt;int&amp;gt;a; std::cout &amp;lt;&amp;lt; a.add(2, 3) &amp;lt;&amp;lt; &quot;\\n&quot;; // example 1 Add&amp;lt;float&amp;gt;b; std::cout &amp;lt;&amp;lt; b.add(2.5, 10.0) &amp;lt;&amp;lt; &quot;\\n&quot;; // example 2 Point&amp;lt;int, int&amp;gt; p; std::cout &amp;lt;&amp;lt; p.addCordinates(10, 20) &amp;lt;&amp;lt; &quot;\\n&quot;; // example 2 Point&amp;lt;int, double&amp;gt; q; std::cout &amp;lt;&amp;lt; q.addCordinates(10, 20.25) &amp;lt;&amp;lt; &quot;\\n&quot;; // example 3 Update&amp;lt;int&amp;gt; u; std::cout &amp;lt;&amp;lt; u.updateBy10(20) &amp;lt;&amp;lt; &quot;\\n&quot;; Update&amp;lt;double&amp;gt; v; std::cout &amp;lt;&amp;lt; v.updateBy10(20.35) &amp;lt;&amp;lt; &quot;\\n&quot;;}Standard Template LibraryThere are three important element in STL, they are Containers: Containers are template class objects that represent a type of data structure and are used to hold data elements of the same type Algorithms: Algorithms are readily available functions which are used with containers to preform specific operations on the data elements present in the containerExample: count(), fill(), swap(), sort(), merge(), equal() Iterators: An iterator is a pointer that points to specific data in the container. it helps in inserting and deleting the data from a container.Container are classified into 3 types they are - Sequential containers - Associative containers - Derived containersThere are 10 different containers available in STL, which are distributed among the mentioned categories of containers Containers Description Header required deque This is a sequence container. This is a double ended queue &amp;lt;deque&amp;gt; list This is a sequence container. This is a linear list &amp;lt;list&amp;gt; map This belongs to associative container. It stores key/value pairs in which one key may be associated with two or more values &amp;lt;map&amp;gt; multimap This belongs to associative container. It stores key/value pairs in which one key may be associated with two or more values &amp;lt;map&amp;gt; multiset This belongs to associative container. This is a set in which each element is not necessarily unique &amp;lt;set&amp;gt; priority_queue This belongs to derived containers. This is a priority queue &amp;lt;queue&amp;gt; queue This belongs to derived containers. This is an ordinary queue &amp;lt;queue&amp;gt; set This belongs to associative container. This is a set in which each element is unique &amp;lt;set&amp;gt; stack This belongs to derived container. This is a stack &amp;lt;stack&amp;gt; vector This belongs to sequential container This is a dynamic array &amp;lt;vector&amp;gt; There are many more added in modern cpp checkout https://www.cplusplus.com/reference/stl/Container class templatesSequence containers:[**array**](https://www.cplusplus.com/reference/array/array/) Array class (class template )[**vector**](https://www.cplusplus.com/reference/vector/vector/)Vector (class template )[**deque**](https://www.cplusplus.com/reference/deque/deque/)Double ended queue (class template )[**forward_list**](https://www.cplusplus.com/reference/forward_list/forward_list/) Forward list (class template )[**list**](https://www.cplusplus.com/reference/list/list/)List (class template )Container adaptors: stackLIFO stack (class template ) queueFIFO queue (class template ) priority_queuePriority queue (class template )Associative containers: setSet (class template ) multisetMultiple-key set (class template ) mapMap (class template ) multimapMultiple-key map (class template )Unordered associative containers: unordered_set Unordered Set (class template ) unordered_multiset Unordered Multiset (class template ) unordered_map Unordered Map (class template ) unordered_multimap Unordered Multimap (class template )" }, { "title": "Never forget to delete an array of object using delete[]", "url": "/posts/never-forget-to-delete-an-array-of-object-using-delete/", "categories": "c++ or cpp", "tags": "c++, cpp, pointers", "date": "2022-05-21 11:24:00 +0530", "snippet": "Never forget to delete an array of object created in heap using delete[].If you forget to do so its really hard to debug especially if you are doing this one in some function some where is your source code and execution hits this delete on some particular conditionAs usual let’s begin with exampleclass Test{public: Test() { std::cout &amp;lt;&amp;lt; &quot;Ctor called\\n&quot;; } ~Test() { std::cout &amp;lt;&amp;lt; &quot;Dtor called\\n&quot;; }};int main(){ Test* p = new Test[2]; //(1) delete p; //(2) return 0;}Here in this above example, Test* p is a pointer pointing to an array of Test objects. In next line we can see delete p is used. When we try to compile this source, compiler does not give an error rather it thrown some warnings. If we ignore this warning then we have a pay it for later.Let’s compile itbhavith@bhavith:~$ g++ main.cpp main.cpp: In function ‘int main()’:main.cpp:21:12: warning: ‘void operator delete(void*, std::size_t)’ called on pointer ‘&amp;lt;unknown&amp;gt;’ with nonzero offset 8 [-Wfree-nonheap-object] 21 | delete p; | ^main.cpp:19:25: note: returned from ‘void* operator new [](std::size_t)’ 19 | Test* p = new Test[2];From the above compiler message we can observer that there is some function like void* operator new[](std::size_t) which we are calling on (1) i.e. new Test[2] that means we are calling an operator [] with size. Then this function returning an pointer i.e. void* and we saving to variable pThe second warning compiler is complaining is, there is a function void operator delete(void*, std::size_t) and we are calling it which we are not suppose to call.In simple words call, operator function associate with delete operator not direct delete.Let’s see what happen when we execute the codebhavith@bhavith:~$ ./a.out Ctor calledCtor calledDtor calledmunmap_chunk(): invalid pointerAborted (core dumped)Did you see that? the application crashed and this is undefined behvaiour many of timesLet’s use gdb to debug itbhavith@bhavith:$ gdb a.out GNU gdb (Ubuntu 12.0.90-0ubuntu1) 12.0.90Copyright (C) 2022 Free Software Foundation, Inc.License GPLv3+: GNU GPL version 3 or later &amp;lt;http://gnu.org/licenses/gpl.html&amp;gt;This is free software: you are free to change and redistribute it.There is NO WARRANTY, to the extent permitted by law.Type &quot;show copying&quot; and &quot;show warranty&quot; for details.This GDB was configured as &quot;x86_64-linux-gnu&quot;.Type &quot;show configuration&quot; for configuration details.For bug reporting instructions, please see:&amp;lt;https://www.gnu.org/software/gdb/bugs/&amp;gt;.Find the GDB manual and other documentation resources online at: &amp;lt;http://www.gnu.org/software/gdb/documentation/&amp;gt;.For help, type &quot;help&quot;.Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...Reading symbols from a.out...(No debugging symbols found in a.out)(gdb) rStarting program: /home/bhavith/Bhavith/Development/blogs/a.out [Thread debugging using libthread_db enabled]Using host libthread_db library &quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;.Ctor calledCtor calledDtor calledmunmap_chunk(): invalid pointerProgram received signal SIGABRT, Aborted.__pthread_kill_implementation (no_tid=0, signo=6, threadid=140737348162496) at ./nptl/pthread_kill.c:4444 ./nptl/pthread_kill.c: No such file or directory.(gdb) bt#0 __pthread_kill_implementation (no_tid=0, signo=6, threadid=140737348162496) at ./nptl/pthread_kill.c:44#1 __pthread_kill_internal (signo=6, threadid=140737348162496) at ./nptl/pthread_kill.c:78#2 __GI___pthread_kill (threadid=140737348162496, signo=signo@entry=6) at ./nptl/pthread_kill.c:89#3 0x00007ffff7b77476 in __GI_raise (sig=sig@entry=6) at ../sysdeps/posix/raise.c:26#4 0x00007ffff7b5d7f3 in __GI_abort () at ./stdlib/abort.c:79#5 0x00007ffff7bbe6f6 in __libc_message (action=action@entry=do_abort, fmt=fmt@entry=0x7ffff7d10b8c &quot;%s\\n&quot;) at ../sysdeps/posix/libc_fatal.c:155#6 0x00007ffff7bd5d7c in malloc_printerr (str=str@entry=0x7ffff7d13230 &quot;munmap_chunk(): invalid pointer&quot;) at ./malloc/malloc.c:5664#7 0x00007ffff7bd605c in munmap_chunk (p=&amp;lt;optimized out&amp;gt;) at ./malloc/malloc.c:3060#8 0x00007ffff7bda51a in __GI___libc_free (mem=&amp;lt;optimized out&amp;gt;) at ./malloc/malloc.c:3381#9 0x000055555555527a in main ()(gdb)From the above debug message we can see program received SIGABRT i.e. abort signal from the kernel and if you back trace it, you can see that call trace is pointing from function main, and abort aroses when control reaches __GI___libc_free function.Moral of the story:Never delete the pointer pointing to any array of object like a regular pointer rather use delete[] pWorking sourceint main(){ Test* p = new Test[2]; delete[] p; //Use this rather delete p return 0;}Compile and rumbhavith@bhavith:~$ g++ main.cppbhavith@bhavith:~$ ./a.out Ctor calledCtor calledDtor calledDtor called" }, { "title": "How member function of a class accesses its data member (Technically, how this pointer works)", "url": "/posts/how-member-function-of-a-class-can-access-data-member/", "categories": "c++ or cpp", "tags": "c++, cpp, pointers, this-pointer", "date": "2022-05-18 21:58:00 +0530", "snippet": "We all know that there is only one copy of function exist’s for N number of objects or instance of a given class.If you don’t understand the above sentence let me first explain with some exampleclass Laptop{public: auto setName(const std::string&amp;amp; name) -&amp;gt; void { m_name = name; }private: std::string m_name = &quot;Dell&quot;;};Here we have a class called Laptop, and we can create ‘N’ number of instances from this class. Then we have ‘N’ number of std::string variable get’s created with name m_name (Technically name mangled m_name). That means if we create two instances, then these two instance has a two std::string variable (Technically object) gets created one for each instance. But tricky part or the fact is, This two instances hash only one copy of the function and it is shared between two instances.Let me give some more clarification with example.int main(){ Laptop instance1; Laptop instance2; instance1.setName(&quot;Lenovo&quot;); instance2.setName(&quot;Asus&quot;); return 0;}In the above example we have created two instances instance1 and instance2. These two instances has its own copy of std::string object with name m_name. But these two instances shares the same function.Now the question is how function know’s which instance’s m_name to use?In order to know this we need to understand what compiler does internally during compilation.What compiler does? Changes the function protoype and body like this auto setName(Laptop* const this, const std::string&amp;amp; name) -&amp;gt; void{ this-&amp;gt;m_name = name;} Changed the caller of function like this Laptop instance1;setName(instance1, &quot;Lenovo&quot;); Now it’s easy isn’t it? because function knows which object’s m_name to use. because its been passed as a first argument to all the member function of the class.This is the beauty of this pointer. That’s why you could able to use this-&amp;gt; in all your member function of class which out being aware from where this magical this comes from.Hey that fine, what about static function?Yes, static function doesn’t have a this pointer because static function doesn’t belongs to instance of the class, rather it belongs to class.What does it mean?Let me show you an example by making setName as static functionstatic auto setName(const std::string&amp;amp; name) -&amp;gt; void{ m_name = name;}As soon as you do this, you’r IDE will prompt with error pointing at m_name as a nonstatic member reference must be relative to a specific objectC/C++(245)Even then if you go ahead and try to compile you get this errorbhavith@bhavith:~$ g++ main.cppmain.cpp: In static member function ‘static void Laptop::setName(const string&amp;amp;)’:main.cpp:10:9: error: invalid use of member ‘Laptop::m_name’ in static member function 10 | m_name = name; | ^~~~~~main.cpp:13:17: note: declared here 13 | std::string m_name = &quot;Dell&quot;; | ^~~~~~From this we know that static function cannot have a this pointer as a first argument to its function and it does not belongs to any of the instances rather its an independent function exist in class and can access only static member variables." }, { "title": "Pointer to a `const` or a `const` pointer", "url": "/posts/const-a-vs-a-const/", "categories": "c++ or cpp", "tags": "c++, cpp, pointers", "date": "2022-05-17 22:15:00 +0530", "snippet": "Many of the times we often see some function, where arguments to functions are like const Animal* pAnimal or Animal* const pAnimal. Our head spins for while especially if we are new to cpp (Often happens to experienced cpp developers as well (lol))auto foo(const Animal* pAnimal) -&amp;gt; void{ ...}Vsauto foo(Animal* const pAnimal) -&amp;gt; void{ ...}Let’s dig in deeper with some example Animal classclass Animal{public: auto setName(const std::string&amp;amp; name) -&amp;gt; void { m_name = name; } auto getName() -&amp;gt; std::string { return m_name; }private: std::string m_name = &quot;Anonymous&quot;; };Lets see ‘const Animal* pAnimal ‘In the above example, Animal class has setter and getter for animal name. Now let’s write a function which takes pointer to an Animal object and print it’s namevoid printAnimalName(Animal* pAnimal){ if (pAnimal) { std::cout &amp;lt;&amp;lt; &quot;Animal name is &quot; &amp;lt;&amp;lt; pAnimal-&amp;gt;getName() &amp;lt;&amp;lt; &quot;\\n&quot;; }}int main(){ Animal* p = new Animal; p-&amp;gt;setName(&quot;Lion&quot;); printAnimalName(p); return 0;}Save the above program as main.cppLet’s compile and execute itbhavith@bhavith:~$ g++ main.cppbhavith@bhavith:~$ ./a.outAnimal name is LionIn function printAnimal, the argument is Animal* pAnimal so we can call it’s member function and even modify the Animal inside function since it is pointer.If we change the argument from Animal* pAnimal to const Animal* pAnimal then we cannot change the value of Animal inside printAnimalNameWhat does it mean that we cannot change the value of Animal?Let’s modify the printAnimal and try to change (set) the value, i.e. name of the Animalvoid printAnimalName(const Animal* pAnimal){ // Change the name of Animal pAnimal-&amp;gt;setName(&quot;Tiger&quot;); if (pAnimal) { // I will talk about this typecast below, as of now forget the below typecast std::cout &amp;lt;&amp;lt; &quot;Animal name is &quot; &amp;lt;&amp;lt; ((Animal*)pAnimal)-&amp;gt;getName() &amp;lt;&amp;lt; &quot;\\n&quot;; }}Let’s compile and see what happensbhavith@bhavith:~$ g++ main.cppmain.cpp: In function ‘void printAnimalName(const Animal*)’:main.cpp:24:21: error: passing ‘const Animal’ as ‘this’ argument discards qualifiers [-fpermissive] 24 | pAnimal-&amp;gt;setName(&quot;Tiger&quot;); | ~~~~~~~~~~~~~~~~^~~~~~~~~main.cpp:7:10: note: in call to ‘void Animal::setName(const string&amp;amp;)’ 7 | auto setName(const std::string&amp;amp; name) -&amp;gt; void | ^~~~~~~Compiler is complaining that user is trying to pass const Animal to function setName as this argument where this pointer is expecting non const Animal object. In simple, user is passing constant value to non const this pointer which is the first argument to setName (Blog on this pointer is coming soon)But we can compile without any error in two ways Type cast the pAnimal from const to non const Pass -fpermissive flag for compiler1. Let’s try with typecastvoid printAnimalName(const Animal* pAnimal){ // typecast ((Animal*)pAnimal)-&amp;gt;setName(&quot;Tiger&quot;); if (pAnimal) { // typecast std::cout &amp;lt;&amp;lt; &quot;Animal name is &quot; &amp;lt;&amp;lt; ((Animal*)pAnimal)-&amp;gt;getName() &amp;lt;&amp;lt; &quot;\\n&quot;; }}compile and runbhavith@bhavith:~$ g++ main.cppbhavith@bhavith:~$ ./a.out Animal name is Tigereverything works smooth now Let’s try with -fpermissive -fpermissive: Downgrade some diagnostics about nonconformant code from errors to warnings. Thus, using -fpermissive will allow some nonconforming code to compile. void printAnimalName(const Animal* pAnimal){ pAnimal-&amp;gt;setName(&quot;Tiger&quot;); if (pAnimal) { std::cout &amp;lt;&amp;lt; &quot;Animal name is &quot; &amp;lt;&amp;lt; ((Animal*)pAnimal)-&amp;gt;getName() &amp;lt;&amp;lt; &quot;\\n&quot;; }}compile and runbhavith@bhavith:~$ g++ main.cpp -fpermissivemain.cpp: In function ‘void printAnimalName(const Animal*)’:main.cpp:24:21: warning: passing ‘const Animal’ as ‘this’ argument discards qualifiers [-fpermissive] 24 | pAnimal-&amp;gt;setName(&quot;Tiger&quot;); | ~~~~~~~~~~~~~~~~^~~~~~~~~main.cpp:7:10: note: in call to ‘void Animal::setName(const string&amp;amp;)’ 7 | auto setName(const std::string&amp;amp; name) -&amp;gt; void | ^~~~~~~bhavith@bhavith:~$ ./a.out Animal name is TigerYes, compiler warn’s that your are doing some thing wrong, but since we used -fpermissive it allowed us to do wrong (lol)Moral of const Animal* pAnimalWe cannot change the value of the animal when it is passed as const Animal* to a function. Since we made Animal as a constant, constant cannot be changed. But as we had seen that we can change by either typecasting or by forcing the compiler by using -fpermissive flagLets see ‘Animal* const pAnimal ‘With the same printAnimalName function let’s change the signature from const Animal* pAnimal to Animal* const pAnimal and compile itvoid printAnimalName(Animal* const pAnimal){ pAnimal-&amp;gt;setName(&quot;Tiger&quot;); if (pAnimal) { std::cout &amp;lt;&amp;lt; &quot;Animal name is &quot; &amp;lt;&amp;lt; ((Animal*)pAnimal)-&amp;gt;getName() &amp;lt;&amp;lt; &quot;\\n&quot;; }}compile and runbhavith@bhavith:~$ g++ main.cppbhavith@bhavith:~$ ./a.out Animal name is TigerHey, what’s this? compiler is not complaining about changing the value of Animal (name of the Animal). We would have used this kind of signature in our first example so that there was no need of typecast neither -fpermissive flag usage while compiling. This is the big catch that every cpp developer get stuck and confused and some how avoid it and move on once it worked.What is the real meaning of Animal* const pAnimal ?What it tells is, pointer (Animal*) is a constant, more specifically it is read-only. In simple, to make understanding much more easy, consider variable pAnimal is read-only variable. That means we cannot reassign this variable to other variable of same type. i.e. other variable of Animal type in this case.Let’s try to reassign the variablevoid printAnimalName(Animal* const pAnimal){ // Create a new Animal object and try to assign this to pAnimal Animal *pAnotherAnimal = new Animal; pAnimal = pAnotherAnimal; //re-assign to new variable (pointer) pAnimal-&amp;gt;setName(&quot;Tiger&quot;); if (pAnimal) { std::cout &amp;lt;&amp;lt; &quot;Animal name is &quot; &amp;lt;&amp;lt; ((Animal*)pAnimal)-&amp;gt;getName() &amp;lt;&amp;lt; &quot;\\n&quot;; }}Compile itbhavith@bhavith:~$ g++ main.cppmain.cpp: In function ‘void printAnimalName(Animal*)’:main.cpp:25:13: error: assignment of read-only parameter ‘pAnimal’ 25 | pAnimal = pAnotherAnimal; | ~~~~~~~~^~~~~~~~~~~~~~~~From the above example you can see that pointer is a constant, i.e. read-only. We cannot assign this variable (pAnimal) to any other object.Moral of Animal* const pAnimalWe cannot change the value of pointer since pointer is constant here. There is no way that typecast or compiler flag works here. This is what the signature of this pointer looks i.e. Animal* const this. i.e. this cannot point to any other object.Comparison and Conclusion const Animal* pAnimal Animal* const pAnimal Animal object is a constant we cannot change the animal Animal pointer is a constant we cannot assign the pointer to another object Used when user don’t want to change the value Used as argument to ensure pointer is not pointing to any other object in the life time of the function or function scope " }, { "title": "Simple way to implement Singleton design pattern without using pointers in c++", "url": "/posts/simple-singleton/", "categories": "design-pattern", "tags": "c++, cpp, design-pattern", "date": "2022-05-10 00:02:00 +0530", "snippet": "A simple way to create a singleton design patternThere are hell lot of example out there online, that how to create a singleton design pattern using pointer and static variable. But here I want to show you how can you create a singleton design pattern without even having a pointer in it. Looks amazing isn’t it?Let’s dive directly into the coding. let say we have Student class below and we want to make it as a singleton. I know this example is not a best example for singleton. For simplicity let’s assume we want to make this Student class a singleton// Student.cppclass Student{public: Student(const std::string&amp;amp; name) : m_name(name) { } ~Student() { m_name = &quot;&quot;; m_books.clear(); } void addBook(const std::string&amp;amp; bookName) { m_books.push_back(bookName); } void printAllBooks() const { for (const auto&amp;amp; book : m_books) { std::cout &amp;lt;&amp;lt; book &amp;lt;&amp;lt; &quot;\\n&quot;; } }private: std::string m_name; std::vector&amp;lt;std::string&amp;gt; m_books {};};int main(){ Student s(&quot;Bhavith&quot;); s.addBook(&quot;Learn C++&quot;); s.addBook(&quot;For the love of physics&quot;); s.printAllBooks(); return 0;}Now let’s make this as a singleton// Student.cppclass Student{public: static Student&amp;amp; instance(const std::string&amp;amp; name) { static Student instance(name); return instance; } void addBook(const std::string&amp;amp; bookName) { m_books.push_back(bookName); } void printAllBooks() const { for (const auto&amp;amp; book : m_books) { std::cout &amp;lt;&amp;lt; book &amp;lt;&amp;lt; &quot;\\n&quot;; } }private: Student(const std::string&amp;amp; name) : m_name(name) { } ~Student() { m_name = &quot;&quot;; m_books.clear(); } std::string m_name; std::vector&amp;lt;std::string&amp;gt; m_books {};};int main(){ auto&amp;amp; s = Student::instance(&quot;Bhavith&quot;); s.addBook(&quot;Learn C++&quot;); s.addBook(&quot;For the love of physics&quot;); s.printAllBooks(); return 0;}In the above example, we moved the constructor and the desctructor private, So that we removed the access to creation of Student object. In order to create a instance, we created an interace called instance which assist in creating the Student instance or object.This approach of creating the singleton is thread-safe because, by default static variable declaration is completely thread-safe in c++, especially after in modern-cpp (c++ onwards) Always go with this approach while making singleton design pattern, which is much more easier, simpler and thread-safestatic Student&amp;amp; instance(const std::string&amp;amp; name){ static Student instance(name); return instance;}This way of implementing the singleton design pattern is called Meyers’ singleton design pattern in simple Spoiler alert: What happen if object is been copied to other object using = operator, then it breaks the singleton design pattern. But how to achieve it is for future post." }, { "title": "pimpl in C++", "url": "/posts/pimpl/", "categories": "c++ or cpp", "tags": "c++, cpp, piml, cpp-techniques", "date": "2022-05-09 23:12:00 +0530", "snippet": "What is pimplIn simple, pimpl is a c++ technique that removes implementation details of a class from its object representation by placing them in a seperate class and accessing it via an opaque pointerWhat the hell is that?Let’s start with simple example.// Student.hclass Student{public: Student(const std::string&amp;amp; name); ~Student(); void addBook(const std::string&amp;amp; bookName); void printAllBooks() const;private: std::string m_name; std::vector&amp;lt;std::string&amp;gt; m_books;};// Student.cppStudent::Student(const std::string&amp;amp; name) : m_name(name){}Student::~Student(){ m_name = &quot;&quot;; m_books.clear();}void Student::addBook(const std::string&amp;amp; bookName){ m_books.push_back(bookName);}void Student::printAllBooks() const{ for (const auto&amp;amp; book : m_books) { std::cout &amp;lt;&amp;lt; book &amp;lt;&amp;lt; &quot;\\n&quot;; }}Now, what’s the problem. The problem is All private variables in Student.h can be seen to all the users of this header file When header file is updated, especially when privates variables are added or removed or modified, Then all the source code which includes this header file get recompiled againHow can we avoid this?This can be avoided using c++ pimpl, What we just need to do is two things, Create a forward declaration of the class with any name (say Impl) in header (Student.h) and add uinque pointer to it as a private member Move all the private variable to Impl class and this class defintion should be present in Student.cpp// Student.hclass Student{public: Student(const std::string&amp;amp; name); ~Student(); void addBook(const std::string&amp;amp; bookName); void printAllBooks() const;private: class Impl; //forward declaration std::unique_ptr&amp;lt;Impl&amp;gt; m_pImpl = nullptr;};Now in above header file we can see that all the private variables are hidden and burried in the source (Student.cpp) file. Only thing which is exposed or seen in the header file is that pointer to impl (Pointer to Implementation).Let’s us look, how can we implement Impl classStudent.cpp looks like this// Student.cppclass Student::Impl{public: Impl(const std::string&amp;amp; name) : m_name(name) { } ~Impl() { m_name = &quot;&quot;; m_books.clear(); } void addBook(const std::string&amp;amp; bookName) { m_books.push_back(bookName); } void printAllBooks() const { for (const auto&amp;amp; book : m_books) { std::cout &amp;lt;&amp;lt; book &amp;lt;&amp;lt; &quot;\\n&quot;; } }private: std::string m_name; std::vector&amp;lt;std::string&amp;gt; m_books;};Student::Student(const std::string&amp;amp; name) : m_pImpl(std::make_unique&amp;lt;Impl&amp;gt;(name)){}Student::~Student(){}void Student::addBook(const std::string&amp;amp; bookName){ if (m_pImpl) { m_pImpl-&amp;gt;addBook(bookName); }}void Student::printAllBooks() const{ if (m_pImpl) { m_pImpl-&amp;gt;printAllBooks(); }}With this above approach we can avoid the exposion of the private details hidden from the header file and also compilation time can be imporvedWhat are the downfall of this approach Very first drawback is, as you had seen in the example, an unnecessary wrapper for each of the function we need to write. Once the program grows bigger and bigger, maintaining this functions become headace Simply we have introduced the pointer and allocated the memory in heap, which would have been much more simpler without pimplWhen can we go for pimpl implementation During the development of the security related functionalities, where we want to hide the private variables, which might be a thridy party variables or any security related data structures or variables When we dont want to break the binary interface which is dependent on private variables" }, { "title": "Be careful when using const reference with std::thread / std::async in C++. Otherwise you may be in soup if you don&#39;t know this ! :)", "url": "/posts/be-careful-when-using-const-reference-with-std-thread-std-async-in-c-otherwise-you-may-be-in-soup-if-you-don-t-know-this/", "categories": "c++ or cpp", "tags": "c++, threading", "date": "2022-04-25 13:42:00 +0530", "snippet": "From the basics of C and C++. we all know that when we use address-of operator to the variable, then it is an alias of the original variable it points to, and shares the same address.Example:#include &amp;lt;iostream&amp;gt;void foo(const int&amp;amp; b) { std::cout &amp;lt;&amp;lt; &quot;Address of variable &#39;b&#39; in foo is &quot; &amp;lt;&amp;lt; &amp;amp;b &amp;lt;&amp;lt; &quot;\\n&quot;;}int main(){ int a = 10; foo(a); std::cout &amp;lt;&amp;lt; &quot;Address of variable &#39;a&#39; in main is &quot; &amp;lt;&amp;lt; &amp;amp;a &amp;lt;&amp;lt; &quot;\\n&quot;; return 0;}outputAddress of variable &#39;b&#39; in foo is 0x7ffcb65f3084Address of variable &#39;a&#39; in main is 0x7ffcb65f3084From the above example you can see address of b used in function foo is same as address of variable a used in main function because we used reference (address-of operator) const int&amp;amp; bAlso the value of b cannot be changed, since its a const variableFun begins now, lets call the function foo in a thread using std::thread and see the output of below code#include &amp;lt;iostream&amp;gt;#include &amp;lt;thread&amp;gt;void foo(const int&amp;amp; b) { std::cout &amp;lt;&amp;lt; &quot;Address of variable &#39;b&#39; in foo is &quot; &amp;lt;&amp;lt; &amp;amp;b &amp;lt;&amp;lt; &quot;\\n&quot;;}int main(){ int a = 10; std::thread t(foo, a); std::cout &amp;lt;&amp;lt; &quot;Address of variable &#39;a&#39; in main is &quot; &amp;lt;&amp;lt; &amp;amp;a &amp;lt;&amp;lt; &quot;\\n&quot;; t.join(); return 0;}outputAddress of variable &#39;a&#39; in main is 0x7ffc4d4126ccAddress of variable &#39;b&#39; in foo is 0x563b96627eb8What the heck? what’s happening here?Here we have passed the value a as argument to function foo and received as reference too. but what happened? Before answering to the question lets remove const from the argument of function foo and see what happensvoid foo(int&amp;amp; b){ std::cout &amp;lt;&amp;lt; &quot;Address of variable &#39;b&#39; in foo is &quot; &amp;lt;&amp;lt; &amp;amp;b &amp;lt;&amp;lt; &quot;\\n&quot;;}outputbhavith $ g++ test.cpp -pthreadIn file included from m2.cpp:2:/usr/include/c++/9/thread: In instantiation of ‘std::thread::thread(_Callable&amp;amp;&amp;amp;, _Args&amp;amp;&amp;amp; ...) [with _Callable = void (&amp;amp;)(int&amp;amp;); _Args = {int&amp;amp;}; &amp;lt;template-parameter-1-3&amp;gt; = void]’:m2.cpp:13:25: required from here/usr/include/c++/9/thread:120:44: error: static assertion failed: std::thread arguments must be invocable after conversion to rvalues 120 | typename decay&amp;lt;_Args&amp;gt;::type...&amp;gt;::value, | ^~~~~/usr/include/c++/9/thread: In instantiation of ‘struct std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)(int&amp;amp;), int&amp;gt; &amp;gt;’:/usr/include/c++/9/thread:131:22: required from ‘std::thread::thread(_Callable&amp;amp;&amp;amp;, _Args&amp;amp;&amp;amp; ...) [with _Callable = void (&amp;amp;)(int&amp;amp;); _Args = {int&amp;amp;}; &amp;lt;template-parameter-1-3&amp;gt; = void]’m2.cpp:13:25: required from here/usr/include/c++/9/thread:243:4: error: no type named ‘type’ in ‘struct std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)(int&amp;amp;), int&amp;gt; &amp;gt;::__result&amp;lt;std::tuple&amp;lt;void (*)(int&amp;amp;), int&amp;gt; &amp;gt;’ 243 | _M_invoke(_Index_tuple&amp;lt;_Ind...&amp;gt;) | ^~~~~~~~~/usr/include/c++/9/thread:247:2: error: no type named ‘type’ in ‘struct std::thread::_Invoker&amp;lt;std::tuple&amp;lt;void (*)(int&amp;amp;), int&amp;gt; &amp;gt;::__result&amp;lt;std::tuple&amp;lt;void (*)(int&amp;amp;), int&amp;gt; &amp;gt;’ 247 | operator()() | ^~~~~~~~What the hell? We are getting compilation error. The important error message to observe is/usr/include/c++/9/thread:120:44: error: static assertion failed: std::thread arguments must be invocable after conversion to rvalues 120 | typename decay&amp;lt;_Args&amp;gt;::type...&amp;gt;::value, | ^~~~~it is complaining that the value passed as a second argument to thread is not a rvalue, we need to convert to rvalue before sending. What is rvalue is an another topic and discuss later.How to convert the argument to rvalue?Just we need to use std::ref class to convert to rvalue. i.e. while calling in thread we need to use like belowstd::thread t(foo, std::ref(a));Note: we wrapper a with std::ref. In this case we created a std::ref object and passed to the argument of function foo in thread.Now lets see the result after fixing the compilation errorAddress of variable &#39;a&#39; in main is 0x7ffc6e26dab4Address of variable &#39;b&#39; in foo is 0x7ffc6e26dab4What the hell it is? Now address of both a and b is same, as soon as we remove the const from argument variableIn order to understand this behavior we need to understand two things that how intelligently the std::thread is implementedWhen const with argument is used how std::thread behaves ?When const with argument is used, we know we are not going to modify the variable any way inside function foo and also compiler will not allow you to do so, then making a reference or alias to original variable may not be thread safe even though if we lock the variable. Because, during the execution of the thread, the passed variable to function foo may changed by main function. Therefore in order to make thread safe std::thread makes a copy of the variable and uses it. So that the copied variable is local to the function and all the local variable to the function is always thread safeWhen const is not used with the argument how std::thread behaves ?When const is not used with the argument of function foo, then std::thread will not make a copy of the variable, Because making a copy will make no sense because changing the variable in main function will not reflect in the function foo and the entire program will not work as expected. Now, in this case it leaves to user of std::thread to take care of thread safety. That means you know what you are doing.The behavior is same w.r.t std::asyncWith const reference#include &amp;lt;iostream&amp;gt;#include &amp;lt;future&amp;gt;void foo(const int&amp;amp; b){ std::cout &amp;lt;&amp;lt; &quot;Address of variable &#39;b&#39; in foo is &quot; &amp;lt;&amp;lt; &amp;amp;b &amp;lt;&amp;lt; &quot;\\n&quot;;}int main(){ int a = 10; auto f = std::async(foo, a); std::cout &amp;lt;&amp;lt; &quot;Address of variable &#39;a&#39; in main is &quot; &amp;lt;&amp;lt; &amp;amp;a &amp;lt;&amp;lt; &quot;\\n&quot;; f.get(); return 0;}outputAddress of variable &#39;a&#39; in main is 0x7ffd413ceedcAddress of variable &#39;b&#39; in foo is 0x55758197bef8Addresses are differentWithout const reference#include &amp;lt;iostream&amp;gt;#include &amp;lt;future&amp;gt;void foo(int&amp;amp; b){ std::cout &amp;lt;&amp;lt; &quot;Address of variable &#39;b&#39; in foo is &quot; &amp;lt;&amp;lt; &amp;amp;b &amp;lt;&amp;lt; &quot;\\n&quot;;}int main(){ int a = 10; auto f = std::async(foo, std::ref(a)); std::cout &amp;lt;&amp;lt; &quot;Address of variable &#39;a&#39; in main is &quot; &amp;lt;&amp;lt; &amp;amp;a &amp;lt;&amp;lt; &quot;\\n&quot;; f.get(); return 0;}outputAddress of variable &#39;a&#39; in main is 0x7ffcd6428a94Address of variable &#39;b&#39; in foo is 0x7ffcd6428a94Shares the same addressSummary Be careful when working with reference and std::thread / std::async. I recommend to always to use const reference since it makes sure shared variables are thread safe provided you don’t want to modify the variable during the execution of the thread. Function argument Variable passed to thread as Address const reference a different address const reference std::ref(a) same address reference std::ref(a) same address " }, { "title": "If you know this in shell script your life is easy", "url": "/posts/if-you-know-this-in-shell-script-your-life-is-easy/", "categories": "shell-script", "tags": "bash, shellscript", "date": "2022-04-25 13:40:00 +0530", "snippet": "There is one thing which we often get confuse in shell script, especially for those who are new to shell scriptingThe difference between $var, ${var} and $(var)echo $varecho ${var}echo $(var)I try to keep the concept as simple as that so that it should be helpful for new beesEven before start, one thing we need to understand is in shell script to echo does not necessarily required quotes to print the message i.e. either double quote “” or single quote ‘’Example:my_shell $ echo &quot;Hello world&quot;Hello worldmy_shell $ echo &#39;Hello world&#39;Hello worldmy_shell $ echo Hello worldHello worldIn above example the output remain same for all the types of echo. Please try yourself w.r.t adding double quote in single quote and vice versa$var - When we echo $var the value saved in var is printedmy_shell $ var=&quot;World&quot;my_shell $ echo Hello $varHello World${var} - There is no difference between $var and ${var} except the way it is used. i.e. if there is a value which need to be print just after variable var then variable var should be enclosed with curly brace i.e. ${var}my_shell $ var=&quot;Linkedin &quot;my_shell $ echo &quot;$varis very famous&quot; very famousIn the above example $varis in echo is considered as one variable. Now in order to tackle this we need to use ${var}my_shell $ var=&quot;Linkedin &quot;my_shell $ echo &quot;$varis very famous&quot; very famousmy_shell $ echo &quot;${var}is very famous&quot;Linkedin is very famousIn the above example you can see now $var is differentiated between the word is just by enclosing in a brace$(var): This is called command substitution and there is no way it is linked or related to $var or ${var}This is used when we want to execute shell command and save the output to variableExample:my_shell $ var=$(echo &quot;Hello world&quot;)my_shell $ echo $varHello worldmy_shell $ echo $(pwd)/home/bhavith/BhavithIn above example observer how var saved the output of echo and pwd outputAnother example:my_shell $ echo &quot;List of files in $(pwd) is&amp;gt;&amp;gt; ---------------------&amp;gt; $(ls)&amp;gt; ---------------------&quot;List of files in /home/bhavith/Bhavith is---------------------c++DevelopmentDocumentsdoWhileJunkopensourceYoutube---------------------In the above example observe how pwd and ls is executed and echoed to console" }, { "title": "Make your life easy &amp; productive with alias in Linux", "url": "/posts/make-your-life-easy-productive-with-alias-in-linux/", "categories": "shell-script", "tags": "bash, shellscript, linux, alias", "date": "2022-04-25 13:39:00 +0530", "snippet": "When I worked first time with Linux (Ubuntu), I use to remember lot of commands required for my project. In order to make myself productive I started creating either a text file called help.txt or create a notes in OneNote to save all those commands. So when ever I need a command I use to copy the command from my help.txt file and use Ctrl + Shift + v to paste on my terminal and go on.One day I had been to Linux training where I observes that, to list the file the trainer was executing ls command, but the output of ls was ls -la. I was totally confused and thought that he might be using some third party ls (As a new bee in Linux world, I assumed that trainer might have done sudo apt-get install third-party-ls or some thing similar).First and foremost his personal PC was also a Linux (Ubuntu distro). The most curious thing which I found was he installed some software in front of me using please install some-software. I had gone mad and without holding my curiosity I asked trainer that how come your system has please instead of sudo. He replied that he is alias sudo to please. Then I nodded my head like as if I know alias and kept quite. Then I searched on internet and found the power of alias and from that day onwards I become a fan of alias.Keeping all the story aside let see what is alias.** In simple alias is a custom name that we can give to any command/commands.**ExampleWith out aliasbhavith@DESKTOP-M98L7FO:/mnt/e/Learning$ ls&#39;Mastering Embedded Linux Programming - Second Edition.pdf&#39; a.out lambda.cpp learning_cmake.pdfbhavith@DESKTOP-M98L7FO:/mnt/e/Learning$With aliasbhavith@DESKTOP-M98L7FO:/mnt/e/Learning$ alias ls=&quot;ls -la&quot;bhavith@DESKTOP-M98L7FO:/mnt/e/Learning$ lstotal 6584drwxrwxrwx 1 bhavith bhavith 4096 Mar 1 22:56 .drwxrwxrwx 1 bhavith bhavith 4096 Mar 2 00:09 ..-rwxrwxrwx 1 bhavith bhavith 6184516 Dec 10 21:05 &#39;Mastering Embedded Linux Programming - Second Edition.pdf&#39;-rwxrwxrwx 1 bhavith bhavith 20976 Mar 1 22:56 a.out-rwxrwxrwx 1 bhavith bhavith 3257 Mar 1 22:57 lambda.cpp-rwxrwxrwx 1 bhavith bhavith 525865 Dec 10 19:22 learning_cmake.pdfbhavith@DESKTOP-M98L7FO:/mnt/e/Learning$How to make alias for multiple commands at onceTo alias multiple commands use function of bash scriptExamplebhavith@DESKTOP-M98L7FO:/mnt/e/Learning$ echo &quot;function setupMyWorkspace()&amp;gt; {&amp;gt; echo &quot;Setting up the workspace&quot;&amp;gt; mkdir myworkspace&amp;gt; cd myworkspace&amp;gt; touch readme.md&amp;gt; echo &quot;Workspace created&quot;&amp;gt; }&quot; &amp;gt; myalias.shbhavith@DESKTOP-M98L7FO:/mnt/e/Learning$ source myalias.shbhavith@DESKTOP-M98L7FO:/mnt/e/Learning$ setupMyWorkspaceSetting up the workspaceWorkspace createdbhavith@DESKTOP-M98L7FO:/mnt/e/Learning/myworkspace$Explanation: Create a function setupMyWorkspace and save it in a file called myalias.sh Source myalias.sh to make this function visible (expose) to running terminal Execute your new command setupMyWorkspace you are doneWhat will happen to my commands if terminal closed ?If you close your terminal then all the alias created will be removed. Again you have to create new alias for one line commands and source myalias.sh to use setupMyWorkspace command.But don’t worry there is way to make your commands available once terminal is opened. The way is paste all your commands to the end of ~/.bashrc file so that every time you open the new terminal all your alias present for you. beautiful right ?Also you can paste your commands in ~/.bash_profile But I don’t recommend to do so. To understand the difference between ~/.bashrc and ~/.bashprofile refer .bashrc Vs .bash_profile blogTips: If you are using bash save your alias in ~/.bashrc and if you are using zsh (Z shell) save in ~/.zshrc If ~/.bashrc (commonly called as rc files) is not present no worry nothing will happen, just create one To know which shell are you using execute echo ${SHELL} then you know which shell is currently you are using examplebhavith@DESKTOP-M98L7FO:/mnt/e/Learning/myworkspace$ echo ${SHELL}/bin/bashbhavith@DESKTOP-M98L7FO:/mnt/e/Learning/myworkspace$Enough is enough please provide your alias 🙂Always try to understand or use your senior’s .bashrc or .vimrc (For vim). I know many of them disagree to provide one, as if there is a rocket science in it. Don’t worry I have pasted some snippet for reference to understand how really we can use alias to make our life easy and productiveBelow is my simple alias snippetalias ev=&quot;vim ~/.vimrc&quot; #Edit .vimrcalias eb=&quot;vim ~/.bashrc&quot; #Edit .bashrc alias rc=&quot;source ~/.bashrc&quot; #Source .bashrc# Git aliases alias gdns=&quot;git diff --ignore-submodules=dirty&quot;alias gco=&quot;git checkout&quot;alias gs=&quot;git status&quot;alias gd=&quot;git diff&quot;alias edit_cscope_vim=&quot;vim ~/.vim/plugin/cscope_maps.vim&quot;alias tr=&quot;tree -L &quot;# Multiple command aliases using functions#Extract iso imagefunction extract_img(){ source_file=$1 dest_file=$(echo $(basename $1) | cut -f 1 -d &#39;.&#39;) dest_gz=$dest_file&quot;.gz&quot; out=$dest_file&quot;_out&quot; echo &quot;Extracing $1 please wait ...&quot; cp $source_file $dest_gz gunzip $dest_gz rm -rf $out;mkdir $out cd $out echo &quot;Uncompressing $dest_file ...&quot; cpio -i &amp;lt;../$dest_file echo &quot;Find the uncompressed image in $out&quot; cd ../ rm -f $dest_file}# Prepare CSCOPE (It also prepare for CTAGS)function pcs(){ echo &quot;Cscope setup started ...&quot; find $(pwd) -name &quot;*.c&quot; -o -name &quot;*.h&quot; &amp;gt; $(pwd)/cscope.files cd $(pwd) cscope -b #ctags too ctags -R CSCOPE_DB=$(pwd)/cscope.out;export CSCOPE_DB echo &quot;Cscope setup is finished !&quot;}# Clean ctags and cscopefunction ccs(){ echo &quot;Cleaning cscope ...&quot; echo &quot;Executing rm cscope.files cscope.out&quot; rm cscope.files cscope.out echo &quot;Cscope cleaned !&quot;}" }, { "title": "Lambda Expression Cheatsheet in C++/CPP", "url": "/posts/lambda-expression-cheatsheet-in-c-cpp/", "categories": "c++ or cpp", "tags": "c++, lambda", "date": "2022-04-25 13:37:00 +0530", "snippet": "With out much theory on what is lambda and what is the history behind it. Lets get straight to the point.I see lot of the developers get confused when they want to use lambda, because they feel irritation by seeing its syntax. But those developers coming from C#, javascript or some other functional programming language they feel happy when they see lambda.C++ developer keep going through lot of videos on YouTube and stack overflow at last end up in a big confuse and stop using it, especially a programmer with 2 or 3 years of experience.To help a new bees in c++ programming I have created a cheat sheet which covers most of the scenarios with Lambda expressions and can improve it further with std::for_each std::bind etc. and do it your selfI assume that reader has little knowledge on function pointers in C. Its good to know function pointer to understand lambda betterIn simple you can use Lambda function where ever normal function is used.Now go through below program which contain all scenarios of lambdaHear is the cheat sheet for lambda cpp#include &amp;lt;iostream&amp;gt;#include &amp;lt;functional&amp;gt;using namespace std;void foo(){}void hello(){ cout &amp;lt;&amp;lt; &quot;Hello&quot; &amp;lt;&amp;lt; endl;}int main(){ int a = 0; int b = 0; // Equivalent to foo (Think it as function without any name) [](){}; // Equivalent to hello [](){ cout &amp;lt;&amp;lt; &quot;Hello&quot; &amp;lt;&amp;lt; endl; }; // But above lambda will not print any thing because we did not called lambda // How to call ? // just use () after lamba like calling regular function [](){ cout &amp;lt;&amp;lt; &quot;Hello printed&quot; &amp;lt;&amp;lt; endl; }(); // () -&amp;gt; calls the lambda // 1. Calculate sum of a and b using lambda a = 10; b = 20; int sum = [](int x, int y) { return x + y; }(a, b); // It calls lambda like function and store the result in variable sum cout &amp;lt;&amp;lt; &quot;sum of &quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &quot; and &quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &quot; is &quot; &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl; // 2. Specify the return type of lambda int sum2 = [](int x, int y) -&amp;gt; int { return x + y; }(a, b); cout &amp;lt;&amp;lt; &quot;sum of &quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &quot; and &quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &quot; is &quot; &amp;lt;&amp;lt; sum &amp;lt;&amp;lt; endl; // 3. How to call lambda later instead of immediate call // std::function needs #include &amp;lt;functional&amp;gt; std::function&amp;lt;int(int, int)&amp;gt; mySum = [](int x, int y) -&amp;gt; int { return x + y; }; cout &amp;lt;&amp;lt; &quot;sum of &quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &quot; and &quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &quot; is &quot; &amp;lt;&amp;lt; mySum(a, b) &amp;lt;&amp;lt; endl; // 4. Use function poiner instead of std::function int (*pMySum)(int, int) = [](int x, int y) -&amp;gt; int { return x + y; }; cout &amp;lt;&amp;lt; &quot;sum of &quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &quot; and &quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &quot; is &quot; &amp;lt;&amp;lt; pMySum(a, b) &amp;lt;&amp;lt; endl; // 5. Point 3 and 4 is hard way, the simpler way is using auto auto autoSum = [](int x, int y) -&amp;gt; int { return x + y; }; cout &amp;lt;&amp;lt; &quot;sum of &quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &quot; and &quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &quot; is &quot; &amp;lt;&amp;lt; autoSum(a, b) &amp;lt;&amp;lt; endl; // 6. Still easy way, i.e. every where auto and no return type required auto stillEasy = [](auto x, auto y) { return x + y; }; cout &amp;lt;&amp;lt; &quot;sum of &quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &quot; and &quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &quot; is &quot; &amp;lt;&amp;lt; stillEasy(a, b) &amp;lt;&amp;lt; endl; // 7. How to calculate sum using variable a and b without // passing as a parameter ? // Here value a and b are passed a value auto sum3 = [a, b]() { return a + b; }; // Observe that we called sum3() not sum3(a, b) cout &amp;lt;&amp;lt; &quot;sum of &quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &quot; and &quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &quot; is &quot; &amp;lt;&amp;lt; sum3() &amp;lt;&amp;lt; endl; // 8. How to save two variable creations using reference // Here values a and b are passed as reference auto sum4 = [&amp;amp;a, &amp;amp;b]() { return a + b; }(); // -&amp;gt; Here I used () so it already called and // no need to call like sum4() just use sum4 as variable // Observe that we called sum4 not sum4() cout &amp;lt;&amp;lt; &quot;sum of &quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &quot; and &quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &quot; is &quot; &amp;lt;&amp;lt; sum4 &amp;lt;&amp;lt; endl; // 9. What if we want all the variable to be passed to lambda from main scope // Then use [=] for pass by value and [&amp;amp;] for pass by reference. // 5.1 pass all variable (a and b) to lambda by value auto sum5 = [=]() { return a + b; }(); // Observe that we called sum5 not sum5() cout &amp;lt;&amp;lt; &quot;sum of &quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &quot; and &quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &quot; is &quot; &amp;lt;&amp;lt; sum5 &amp;lt;&amp;lt; endl; // 5.2 pass all variable (a and b) to lambda by reference auto sum6 = [&amp;amp;]() { return a + b; }; // Observe that we called sum6() not sum6 just for a combinations cout &amp;lt;&amp;lt; &quot;sum of &quot; &amp;lt;&amp;lt; a &amp;lt;&amp;lt; &quot; and &quot; &amp;lt;&amp;lt; b &amp;lt;&amp;lt; &quot; is &quot; &amp;lt;&amp;lt; sum6() &amp;lt;&amp;lt; endl; return 0;}In Lambda Symbol Description [ ] Capture list where we can capture list of variable either by reference or by value ( ) Arguments similar to function argument { } Lambda body which is similar to lambda body Bonus:int a, b; Symbol Description [=] Capture all the variables (a and b) as value [&amp;amp;] Capture all the variables (a and b) as reference [&amp;amp;a] Capture only a as reference and access to b in lambda gives compilation error [&amp;amp;a, b] Capture variable a as reference and b by value We can pass any number of items in capture list like [&amp;amp;a, b, c, &amp;amp;d]We can pass all the values by reference expect one Ex: [&amp;amp;, b] -&amp;gt; All the values are captures by reference except bReturn type:[ ]( )-&amp;gt;return_type{};Here return_type is optional" }, { "title": ".bashrc Vs .bash_profile", "url": "/posts/bashrc-vs-bash-profile/", "categories": "shell-script", "tags": "bash, shellscript", "date": "2021-10-29 20:02:00 +0530", "snippet": "What is the difference between .bashrc and .bash_profileSometime many of us get confused whether to place our alias, export’s and init things in .bashrc or **.bash_profile. **The answer to this doubt is very simple. Whenever you want to execute the commands automatically when user logins, place them in .bash_profile. Similarly whenever you want to execute the commands automatically when terminal is opened or /bin/bash is executed place then in .bashrcIn simple words, When user logs in to the Linux using username and password either locally or from remote via ssh the .bash_profile gets invoked When user open’s a new terminal or executes /bin/bash the .bashrc gets invokedFurther informationBasically .bashrc and .bash_profile are the two hidden files which are present under home directory in Unix like operating system(s). These are the files which is used to execute shell commands during login or when terminal is opened. RC in bashrc stands for run command.Tips:If you want to execute same commands both in .bash_profile and .bashrc. Place them only in .bashrc and source .bashrc inside .bash_profileExample:~/.bash_profilesource ~/.bashrc~/.bashrcalias l=”ls -ltr”alias v=”vim”alias gp=&quot;git pull&quot;In above example both when user logs in and terminal is invoked .bashrc is invokedNote: Each Unix like operating system have their own conventions, some OS use .profile ** instead of **.bash_profile If your shell is bash then you have .bashrc, similarly if you using zsh then rc file will be .zshrc. Even vim and other applications like task uses same method to give user the flexibility to do some initialization stuff. Vim uses .vimrc and task(Taskwarrior) uses .taskrc to run initial commands" } ]
